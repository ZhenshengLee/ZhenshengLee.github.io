[{"title":"【Ubuntu】常用系统维护","date":"2016-11-22T08:46:27.576Z","path":"2016/11/22/160716常用系统维护/","text":"前言 纯粹笔记，以防忘记 记录在live cd 下为某磁盘安装grub 从live cd 进入ubuntu123sudo sufdisk -l mount /dev/sdc1 这是某磁盘ubuntu 启动分区 1grub-install --root-directory=/mnt /dev/sdc 重启电脑进入该磁盘，会报错，但可以正常进入ubuntu，然后在该系统中更新即可！ 1sudo update-grub 挂载1sudo mount -o loop -t hfsplus imagefile.img /mnt 更改主显示器1xrandr 查看显示器详细信息 1xrandr --output DFP5 --auto --primary 查看设备1ls /dev/ | grep video grub 图形化编辑123sudo add-apt-repository ppa:danielrichter2007/grub-customizersudo apt-get updatesudo apt-get install grub-customizer 查找 package1dpkg -l | grep xmind 查询链接库依赖项1.../platforms$ ldd libqxcb.so 删除文件夹1sudo rm -rf ./Robai/ 查找包1apt-cache search pcl 卸载包1sudo dpkg -r pcl 卸载软件1sudo apt-get remove ros-indigo-moveit-full grub12sudo cp /etc/default/grub /etc/default/grub.baksudo gedit /etc/default/grub GRUB_DEFAULT=GRUB_TIMEOUT=5 1sudo update-grub 修改hosts文件1234sudo gedit /etc/hostssudo rcnscd restartsudo apt-get install nscdsudo /etc/init.d/nscd restart 127.0.1.1 zsUbuntu Choose server Choose the ubuntu server sjtu.edu.cn su 命令失败 试试sudo su进入root模式 环境变量1env 查看环境变量 1set 查看所有变量（环境变量+自定义变量） 12echo $&#123;PATH&#125;PATH=&quot;$PATH&quot;:&apos;/home/zs/VSCode-linux-x64&apos; 添加路径至PATH环境变量路径可以不加单引号 1echo $$ 当前线程的PID号码 1echo $? 上个命令的回传码（没错为0） 1export 自定义变量转成环境变量，子进程仅会继承父进程的的环境变量，而不会继承自定义变量declare反过来 1export PYTHONPATH=~/Documents/zsProjects/zsNao/zsROSNaoqi/pynaoqi-python2.7-2.1.4.13-linux64:$PYTHONPATH 添加环境变量 1echo &apos;export PYTHONPATH=~/Documents/zsProjects/zsNao/zsROSNaoqi/pynaoqi-python2.7-2.1.4.13-linux64:$PYTHONPATH&apos; &gt;&gt; ~/.bashrc 永久添加环境变量 更新1234sudo apt-get updatesudo apt-get dist-upgradesudo apt-get autoremovesudo apt-get autoclean 安装1sudo aptitude install name 更改计算机名12sudo gedit /etc/hostnamesudo gedit /etc/hosts 两个地方的名字需一致 网络远程登陆工具 ssh 查看网速 nload 启动器上应用程序图标为灰色问号？123cd ～/.local/share/applications/gedit $&#123;某一个桌面快捷方式文件&#125;$&#123;ICON&#125;变量进行设置 处理包冲突问题技巧1aptitude Getting Help: When asking for help on Askubuntu or any other help forum, you should include the output of the following commands in your question:1sudo apt-get install package-name Output of actual error. 1cat /etc/apt/sources.list This will show your sources.list 1cat /etc/apt/sources.list.d/* This will show the list of PPAs (If any). Umet dependencies——软件安装包冲突时的解决思路 备份APT源数据文件 APT is a package management system for Debian and other Linux distributions based on it, such as Ubuntu. For the most part, APT is easy to use for installing, removing, and updating packages. In rare instances, often when you are mixing in third-party dependencies, there is a chance that apt-get may end up giving you an error telling you that a package installation could not be completed.It is always a good idea to back up configuration files like /etc/apt/sources.list, so you can revert the changes if needed. 版本号不一致，有一个版本已经安装，但是你要安装另一个版本 If the error shows something like this:: Depends: (= version) but this-version is to be installedThen make sure that the restricted and universe repositories are enabled. Hit Alt+F2, type software-properties-gtk and hit Enter.Under Ubuntu Software tab, enable all the repositories. 12sudo apt-get cleansudo apt-get autoclean One possible cause of unmet dependencies could be corrupted package database, and/or some packages weren’t installed properly. To fix this problem, hit Alt+Ctrl+T to open terminal and try to run one of the following commands:apt-get clean clears out the local repository of retrieved package files (the .deb files). It removes everything but the lock file from /var/cache/apt/archives/ and /var/cache/apt/archives/partial/. apt-get autoclean clears out the local repository of retrieved package files, but unlike apt-get clean, it only removes package files that can no longer be downloaded, and are largely useless. autoclean基本没什么用，clean有用一些 1sudo apt-get -f install One of the most basic fixes to resolve dependencies problems is to run:The -f here stands for “fix broken”. Apt will attempt to correct broken dependencies. If you manually installed a package that had unmet dependencies, apt-get will install those dependencies, if possible, otherwise it may simply remove the package that you installed in order to resolve the problem.Then run: 1sudo dpkg --configure -a Then run this again: 1sudo apt-get -f install If the output is:0 upgraded, 0 newly installed, 0 to remove and 1 not upgraded.That means it failed. 1sudo apt-get -u dist-upgrade Next solution is to run: 1sudo apt-get -o Debug::pkgProblemResolver=yes dist-upgrade If it shows any held packages, it is best to eliminate them. Packages are held because of dependency conflicts that apt cannot resolve. Try this command to find and repair the conflicts:If it cannot fix the conflicts, it will exit with:0 upgraded, 0 newly installed, 0 to remove and 6 not upgraded. 1sudo apt-get remove --dry-run package-name Delete the held packages one by one, running dist-upgrade each time, until there are no more held packages. Then reinstall any needed packages. Be sure to use the –dry-runoption, so that you are fully informed of consequences:Since removing the package you are trying to install may not be ideal, you might also try finding a repository that has the packages you need to satisfy the dependencies. 使用命令计算处有错误的包集，尝试删除之，注意所有删除的细节，免得造成不好后果。Finally, if all else fails, you can attempt to satisfy the dependencies yourself, either by finding and installing the necessary packages, or by installing them from source and then creating “deb” packages for them. 如果所有的都失败了，没办法了，手动找吧。删除或者安装 关于PPAs(Personal Package Archive) PPAs (Personal Package Archive) are repositories hosted on Launchpad. You can use PPAs to install or upgrade packages that are not available in the official Ubuntu repositories. One of the most common causes of unmet dependencies are PPAs, specially when used to upgrade the existing package in Ubuntu repositories. To solve the problem you have three options, disable, purge (revert back to original package in Ubuntu repositories) or remove PPA. Disable: Disabling a PPA means no more updates for the packages installed from that PPA. To disable a PPA: Open Software Center &gt; Edit &gt; Software Sources Or, Hit Alt+F2 and run software-properties-gtk.Click on Other Software tab, you’ll see that each PPA have two lines here, one for the compiled packages and one for the source, Uncheck both lines to disable a PPA. Here you can also add and remove PPAs.Purge: Purging a PPA means, downgrading the packages in the selected PPA to the version in the official Ubuntu repositories and disabling that PPA. PPA Purge does exactly that. To install PPA Purge run the following command:1sudo apt-get install ppa-purge But, Considering the question apt is broken so the above command will fail. So use this command 1mkdir ppa-purge &amp;&amp; cd ppa-purge &amp;&amp; wget http://mirror.pnl.gov/ubuntu/pool/universe/p/ppa-purge/ppa-purge_0.2.8+bzr56_all.deb &amp;&amp; wget http://mirror.pnl.gov/ubuntu//pool/main/a/aptitude/aptitude_0.6.6-1ubuntu1_i386.deb &amp;&amp; sudo dpkg -i ./*.deb To use PPA Purge: 1sudo ppa-purge ppa:someppa/ppa If ‘ppa-purge’ command fails for some reason, you can’t run ‘ppa-purge’ again unless you re-enable the PPA (To enable the PPA follow the same steps as disabling a PPA and Check the both lines of a particular PPA to enable it).Note: PPA Purge doesn’t remove PPAs (may be in future), So you’ll have to manually remove the PPA. Remove: If the package installed from a PPA doesn’t exist in official Ubuntu repositories then using PPA Purge is not recommended, because there’s nothing to be downgraded and PPA Purge wouldn’t delete it either. To remove a PPA and installed packages run the following commands: (Ignore the first command if you don’t want to remove the installed packages) 123sudo apt-get autoremove --purge package-namesudo add-apt-repository --remove ppa:someppa/ppasudo apt-get autoclean Alternatively you can use Y PPA Manager to disable/remove/purge PPA’s (Details at the end of answer). Preventive Measures: So how can we avoid this from happening in the first place? Keep Ubuntu Up to date. Ubuntu automatically notifies when updates are available, you can also check for available updates by clicking on Session Indicator in Unity panel:Or, Hit Alt+Ctrl+T to open terminal and run following commands: 12sudo apt-get update sudo apt-get upgrade Update: Synchronizes your list of available packages with the servers in source repositories. Upgrade: Downloads &amp; installs any newer versions of your installed packages. 常更新！ If you decide to add other repositories to sources.list, make sure that the repository is meant to work (and known to work) with Ubuntu. Repositories that are not designed to work with your version of Ubuntu can introduce inconsistencies in your system and might force you to re-install. Also, make sure that you really need to add external repositories as the software package(s) you are looking for may already have been introduced into the official repositories! 添加源时应谨慎，一定要添加么？这个软件适合当前Ubuntu版本么？这个外部源是否已经存在于官方源中了呢？ Remove duplicate PPAs. Y PPA Manager (installation guide at the end of answer) can easily scan and remove duplicate PPAs.Hit Alt+F2 and run y-ppa-manager to open Y PPA Manager.Once open, double click or hit Enter on Advanced.In resulting window select Scan and remove duplicate PPAs and click OK. 双硬盘同引导双系统 先认真把《鸟叔》看懂！ 基本条件，SSD（sd0）装windows，同时HDD（sd1）作为数据盘；计划把Ubuntu安装在HDD的一个分区中，分/swap，/boot，/，/home 四个分区；但是第一次安装，建议就在HDD中的F盘，主分区中安装吧，F盘是HDD的一个分区 重新分区的问题 恢复分区怎么处理？（恢复分区是主分区，而且有三个，删除哪些？要弄懂） 安装Ubuntu要不要分多个区？（不打算分swap） / 和/home最好分别mount到ssd和hard drive上！ 打算这样：SSD上/分18G；HDD上F盘100G分出两个分区用来装/usr和/home 考虑到/var也很费内存，则考虑在SSD上只安装/boot，F盘分两个装/和/home 这样重装系统时候只需格式化/boot和/分区，继续挂载/home分区现在这样，在SSD上的512M地方放/boot，在F盘的扩展分区分两个区，bootloader安装在SSD上 装系统实践 备份文件；制作安装U盘；删除卷；检查BIOS； 实测：当前windows还是在HDD的启动扇区进去的，不知道为什么，所以现在的方式是在F盘中分/和/home，bootloader安装在HDD中，注意如果有选择HDD的哪一个分区的话，马上取消，查答案。（结果是，既可以选在硬盘的第一个扇区，也可以选择硬盘的某一个分区的扇区） 关于device for boot loader installation 这个bootloader 其实是grub，即选择grub的安装位置 device for boot loader installation的选择（grub的安装位置），如果选择整个硬盘，则开机启动时win会被ubuntu管理启动（用grub引导 windows），这样卸载ubuntu后，win也会将启动丢失，引起系统进不去的问题（当然可以修复）；如果device for boot loader installation选择ubuntu的/boot所在的分区后，下次启动会默认进入win，这时只要在win下用freebcd添加个ubuntu的引导就行了。 装完系统后请关闭windows的快速启动，不然关机后再次启动直接进Linux无法挂载windows磁盘，因为windows并未真正关闭 当然，如果不关闭快速启动，可以每次开机默认进入windows，然后想使用Linux时按重新启动即可。 设置Grub，配置文件，设置默认启动项和等待秒数 缺少库文件 原因一般有两个, 一个是操作系统里确实没有包含该共享库(lib.so.文件)或者共享库版本不对, 遇到这种情况那就去网上下载并安装上即可. 另外一个原因就是已经安装了该共享库, 但执行需要调用该共享库的程序的时候, 程序按照默认共享库路径找不到该共享库文件. 共享库路径设置问题, 如下: 如果共享库文件安装到了/lib或/usr/lib目录下, 那么需执行一下ldconfig命令ldconfig命令的用途, 主要是在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下, 搜索出可共享的动态链接库(格式如lib.so), 进而创建出动态装入程序(ld.so)所需的连接和缓存文件. 缓存文件默认为/etc/ld.so.cache, 此文件保存已排好序的动态链接库名字列表. 如果共享库文件安装到了/usr/local/lib(很多开源的共享库都会安装到该目录下)或其它”非/lib或/usr/lib”目录下, 那么在执行ldconfig命令前, 还要把新共享库目录加入到共享库配置文件/etc/ld.so.conf中, 如下: 1234# cat /etc/ld.so.confinclude ld.so.conf.d/*.conf# echo &quot;/usr/local/lib&quot; &gt;&gt; /etc/ld.so.conf# ldconfig 如果共享库文件安装到了其它”非/lib或/usr/lib” 目录下, 但是又不想在/etc/ld.so.conf中加路径(或者是没有权限加路径). 那可以export一个全局变量LD_LIBRARY_PATH, 然后运行程序的时候就会去这个目录中找共享库. LD_LIBRARY_PATH的意思是告诉loader在哪些目录中可以找到共享库. 可以设置多个搜索目录, 这些目录之间用冒号分隔开. 比如安装了一个mysql到/usr/local/mysql目录下, 其中有一大堆库文件在/usr/local/mysql/lib下面, 则可以在.bashrc或.bash_profile或shell里加入以下语句即可:export LD_LIBRARY_PATH=/usr/local/mysql/lib:$LD_LIBRARY_PATH 一般来讲这只是一种临时的解决方案, 在没有权限或临时需要的时候使用.","tags":[{"name":"其他","slug":"其他","permalink":"https://ZhenshengLee.github.io/tags/其他/"}]},{"title":"【建站】开开心心建网站","date":"2016-11-22T08:46:24.888Z","path":"2016/11/22/160619开开心心建网站/","text":"前言 本来准备在CSDN上建个博客，后来为了能够更加自动化，还是在GitHub Pages 上弄一个 [TOC] 步骤准备123456wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | shnvm install nodenpm install -g hexo-cli 建立github.io项目 本地建站123456mkdir zsBlogcd ./zsBlog/hexo init 第一个页面12hexo generatehexo server Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 进入浏览器访问页面即可 创建一个页面并预览1hexo new &quot;Zhensheng的第一个博客&quot; Created: ~/zsBlog/source/_posts/Zhensheng的第一个博客.md 1234cd source/_postscode ./Zhensheng的第一个博客hexo generatehexo server 浏览器访问预览 设置一个主题123cd ~/zsBloggit clone https://github.com/litten/hexo-theme-yilia.git themes/yiliacode ./_config.yml 更改这一行 1theme: yilia 主题配置123456cd themes/yiliacode ./_config.ymldeploy:type: gitrepo: git@github.com:ZhenshengLee/ZhenshengLee.github.io.gitbranch: master 更新并部署 123hexo cleanhexo generatehexo deploy deploy 没反应1npm install hexo-deployer-git --save Hexo配置首页显示摘要 如果你需要主页显示文章全部内容，只显示摘要的话，就在文章中加一行 &lt;!–more—&gt; 在这个标记之前的就是摘要 关于位置显示”Über” 使用CLion替换所有文件中的此单词，替换为About 多说评论1234subl themes/yilia/layout/_partial/post/duoshuo.ejsvar duoshuoQuery = &#123;short_name:&quot;zhenshenglee&quot;&#125;; 注册google_analytics添加RSS12npm install hexo-generator-feed --save 添加sitemap123npm install hexo-generator-sitemap --savehexo cleanhexo g 最后的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 哈骑士的博客subtitle: 将科技固化为产品——机器人软件开发description: 点滴记录，学习成长author: 黎振胜language: zh-Hanstimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://ZhenshengLee.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace: style: 'github'# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# theme: landscapetheme: yilia# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:ZhenshengLee/ZhenshengLee.github.io.git branch: master# RSS订阅plugin: - hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 Yilia主题配置 最后的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146# Headermenu: 主页: / 所有文章: /archives/ 写在前面: /front_page/ 机器人软件构造: /tags/software_build/ 机器人软件设计: /tags/software_design/ 机器人系统开发: /tags/system_dev/ 机械设计: /tags/machine_design/ # 机器视觉: /tags/机器视觉/ # 深度学习: /tags/深度学习/ # 其他: /tags/others/ # 关于: /about/# SubNavsubnav: github: \"https://github.com/ZhenshengLee\" #weibo: \"#\" #rss: \"/atom.xml\" #zhihu: \"#\" #douban: \"#\" mail: \"mailto://lzs_1993@qq.com\" #facebook: \"#\" #google: \"#\" #twitter: \"#\" linkedin: \"https://cn.linkedin.com/in/zhenshengli\"rss: /atom.xml# Contentexcerpt_link: 阅读全文fancybox: truemathjax: true# 是否开启动画效果animate: true# 是否在新窗口打开链接open_in_new: false# Miscellaneousgoogle_analytics: ''favicon: /favicon.png#你的头像urlavatar: \"http://7xvunf.com1.z0.glb.clouddn.com/%E5%85%B6%E4%BB%96320X425.jpg\"#是否开启分享share_jia: trueshare_addthis: false#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-keyduoshuo: trueduoshuo_shortname: zhenshenglee#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论#是否开启云标签tagcloud: true#是否开启友情链接#不开启——#friends: false#开启——friends: # 奥巴马的博客: http://localhost:4000/ # 卡卡的美丽传说: http://localhost:4000/ # 本泽马的博客: http://localhost:4000/ # 吉格斯的博客: http://localhost:4000/ # 习大大大不同: http://localhost:4000/ # 托蒂的博客: http://localhost:4000/#是否开启“关于我”。#不开启——#aboutme: false#开启——aboutme: 机械电子工程在读研究生，从事协作机器人软件开发，正在找工作 其他设置vscode .npmignore中添加.vscode 致谢 YanceyWang 一个更全的包括hexo配置的介绍 yilia主题设置 配置多说 主题优化 图标制作","tags":[{"name":"其他","slug":"其他","permalink":"https://ZhenshengLee.github.io/tags/其他/"}]},{"title":"161107-thunderbird配置","date":"2016-11-07T12:26:57.000Z","path":"2016/11/07/161107-thunderbird配置/","text":"邮箱软件增强前言 属于日常维护系列 参考 奔歌版配置教程 Thunderbird chrome 配置文件 using lighting with google calander 边栏字体 使用tweak更换字体之后不需要调整字体大小也能在高分屏上正常观看了 插件 Adblock Plus Lightning and Provider for google calander Manually sort folders! Thunderbird conversations 新建谷歌日历 New-Calander-on the network","tags":[{"name":"其他","slug":"其他","permalink":"https://ZhenshengLee.github.io/tags/其他/"}]},{"title":"【组件】ompl-open motion planning library2-omplapp","date":"2016-10-05T04:18:45.000Z","path":"2016/10/05/161005-ompl2-使用omplapp/","text":"前言 使用ompl前端工具 [TOC] 参考 CMake issue installing omplappno moudule name _utilinstalling of Py++Python binding failed 学习记录安装 castxml，若没有安装的话 12wget -O - https://midas3.kitware.com/midas/download/item/318227/castxml-linux.tar.gz | tar zxf - -C $HOMEexport PATH=$HOME/castxml/bin:$PATH pygccxml，若没有安装的话 1sudo pip install pygccxml https://bitbucket.org/ompl/pyplusplus/get/1.6.tar.gz py++，如果没有安装的话 1sudo apt-get install python-py++ 或者（最好都装吧，我搞怕了） 1234/usr/bin/wget --no-check-certificate -O - https://bitbucket.org/ompl/pyplusplus/downloads/pyplusplus-r1247.tgz | tar xzf -cd ../pyplusplus/usr/bin/python setup.py buildsudo /usr/bin/python setup.py install 参考网页，下好依赖项，代码不赘述，主要注意几点： 记得将ompl文件夹（就是核心库文件夹，需要另外下载）放置到omplapp/ cmake 找不到libccd，是因为找到了ros中的旧版本文件，此时需要对环境变量进行一下设置，以便让pkg_config先查询/usr/local/lib哎，linux下的包配置真是满满的恶意！ 1export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH 1234567cd ./build/Releasecmake -DCMAKE_BUILD_TYPE=Release ../..make update_bindings -j4# 注意，如果内存不够大，请不要用-j4，不然会出现未知错误！make -j4sudo make install# 请耐心等待 make 通不过 运行实例 启动前端界面 ./ompl_app.py","tags":[{"name":"机器人软件设计","slug":"机器人软件设计","permalink":"https://ZhenshengLee.github.io/tags/机器人软件设计/"}]},{"title":"【设计】CMake专题-finding libraries","date":"2016-10-05T04:15:02.000Z","path":"2016/10/05/161005-CMakeFind模块/","text":"前言 cmake 过程中总是出现找不到模块，所以学习一下，最好要会写FindXXX.cmake [TOC] 参考 cmake wiki: how to find librariesHow_to_create_a_ProjectConfig.cmake_filecmake documentation: home pageFind package exampleMartin K, Hoffman B. Mastering CMake[M]. Kitware, 2015. 学习记录基础知识 使用VERBOSE=1来检查各种构建选项。 在/build/Release/…/CMakeFiles/${cmake_target}.dir/中，有四个文件，用作CMake对依赖项的分析： depend.make：存储依赖项信息 flag.make：存储编译选项，如果该文件改变，将重新编译 build.make：依赖项如何构建，如果该文件改变，CMake将重新计算依赖 DependInfo.cmake：当前项目中有哪些文件和哪些语言 add_library(foo STATIC foo1.c foo2.c) 注意第一个参数是目标名，第二个参数是目标的修饰词，如果没有这个修饰词，那么将检查环境变量BUILD_SHARED_LIBS，如果没有定义这个环境变量，则按默认，生成静态链接库 target_link_libraries(foo bar) bar可为：库名字，库的完整路径名和之前用add_library()指令生成的库名 环境变量有局部特性：意味着子函数，子路径，子CMake指令中的变量名字不会影响上一个环境 函数举例 123456789function(foo) message($&#123;test&#125;) # test is 1 here set(test 2 PARENT_SCOPE) message($&#123;test&#125;) # test is still 1 in this scopeendfunction()set(test 1)foo()message($&#123;test&#125;) # test will now be 2 here 循环举例 1234set (items_to_buy apple orange pear beer)foreach (item $&#123;items_to_buy&#125;) message(\"Don't forget to buy one $&#123;item&#125;\")endforeach() CMake Cache 作用：缓存，下一次可以直接用；人机界面使用这个信息 注意：一旦Cache中有了信息，则只能通过人机界面来修改？ 用法：option(USE_JPEG “DO you want to use jepg library?”)，这句话会创建一个变量名存入Cache。 直接使用CACHE option set(USE_JPEG ON CACHE BOOL “include jpeg support?”) ON：变量值；CACHE：选项；BOOL：变量类型；”include jepg …”：文档字符串 1234567891011find_library(TIFF_LIBRARY NAMES tiff tiff2 PATHS /usr/local/lib /usr/lib )find_path(TIFF_INCLUDES tiff.h /usr/local/include /usr/include )include_directories($&#123;TIFF_INCLUDES&#125;)add_executable(mytiff mytiff.c)target_link_libraries(myprogram $&#123;TIFF_LIBRARY&#125;) find_library 当不同的系统，相同的库文件被安装在不同路径下时，就需要使用这个命令 只需要库的base name，即不需要libtiff，libtiff2，或者tiff.so，tiff.so.2 find命令，会去${PATH}里面找文件 命令会默认创建CACHE find_path 当不同的系统，相同的头文件被安装在不同路径下时，就需要使用这个命令 其他和find_library差不多 find_package ./Modules/里面有默认的FindXX.cmake，运行这个命令就相当于运行这个.cmake文件，如果找到模块，则赋予多个环境变量值 find_package详解使用外部库 CMake原生支持许多module的寻找，通过cmake –help-modul-list，可以查看，相关原生.cmake文件存放在/usr/share/cmake/Modules/ 如果在网上找到了FindXXX.cmake文件 第一步，检查这个包是否是必须的，如果不是必须，将REQUIRED关键字去掉即可 如果该包必须，则将此文件放入你的当前项目的./cmake/modules/中，然后在根目录的CMakeLists文件中，添加1set(CMAKE_MODULE_PATH $&#123;CMAKE_MODULE_PATH&#125; \"$&#123;CMAKE_SOURCE_DIR&#125;/cmake/Modules/\") 带有组件的库 注意，以下句子都是等同的 123456find_package(Qt COMPONENTS QtOpenGL QtXml REQUIRED)find_package(Qt COMPONENTS QtOpenGL QtXml REQUIRED)find_package(Qt REQUIRED COMPONENTS QtOpenGL QtXml)find_package(Qt REQUIRED QtOpenGL QtXml) 会产生__FOUND find_package工作机制 寻找Findxxx.cmake文件，首先到${CMAKE_MODULE_PATH}中找，然后在自己的/modules/中找。 如果没有找到，则寻找Config.cmake or -config.cmake，这些是一些库在安装时候自动生成的，不过一般不会被生成。 找到之后，生成以下变量 _FOUND _INCLUDE_DIRS or _INCLUDES _LIBRARIES or _LIBRARIES or _LIBS _DEFINITIONS pkg-config 当某一个库没有内建cmake支持时，无法生成Findxxx.cmake文件进行搜索，可以借助这个工具进行寻找。 不过请注意：这个工具生成的结果不可靠 自己写findxxx.cmake传统方法 注意，该文件名需要符合特定的规则 使用find_package命令来找到这个包的依赖项。 使用pkd-config来检测包含文件/库文件的目录 使用find_path和find_library来确定库文件和头文件 pkg-config的生成结果可以作为候选搜索目录 添加一些一定会存在的目录 命令执行后会生成变量 Set _INCLUDE_DIRS to _INCLUDE_DIR _INCLUDE_DIRS … Set _LIBRARIES to _LIBRARY _LIBRARIES … Call the find_package_handle_standard_args() macro to set the _FOUND variable and print a success or failure message. 12345678910111213141516171819202122232425262728# - Try to find LibXml2# Once done this will define# LIBXML2_FOUND - System has LibXml2# LIBXML2_INCLUDE_DIRS - The LibXml2 include directories# LIBXML2_LIBRARIES - The libraries needed to use LibXml2# LIBXML2_DEFINITIONS - Compiler switches required for using LibXml2 find_package(PkgConfig)pkg_check_modules(PC_LIBXML QUIET libxml-2.0)set(LIBXML2_DEFINITIONS $&#123;PC_LIBXML_CFLAGS_OTHER&#125;) find_path(LIBXML2_INCLUDE_DIR libxml/xpath.h HINTS $&#123;PC_LIBXML_INCLUDEDIR&#125; $&#123;PC_LIBXML_INCLUDE_DIRS&#125; PATH_SUFFIXES libxml2 ) find_library(LIBXML2_LIBRARY NAMES xml2 libxml2 HINTS $&#123;PC_LIBXML_LIBDIR&#125; $&#123;PC_LIBXML_LIBRARY_DIRS&#125; ) include(FindPackageHandleStandardArgs)# handle the QUIETLY and REQUIRED arguments and set LIBXML2_FOUND to TRUE# if all listed variables are TRUEfind_package_handle_standard_args(LibXml2 DEFAULT_MSG LIBXML2_LIBRARY LIBXML2_INCLUDE_DIR) mark_as_advanced(LIBXML2_INCLUDE_DIR LIBXML2_LIBRARY ) set(LIBXML2_LIBRARIES $&#123;LIBXML2_LIBRARY&#125; )set(LIBXML2_INCLUDE_DIRS $&#123;LIBXML2_INCLUDE_DIR&#125; ) 借助LibFindMacros宏1234567891011121314151617181920212223242526272829303132# - Try to find ImageMagick++# Once done, this will define## Magick++_FOUND - system has Magick++# Magick++_INCLUDE_DIRS - the Magick++ include directories# Magick++_LIBRARIES - link these to use Magick++ include(LibFindMacros) # Dependencieslibfind_package(Magick++ Magick) # Use pkg-config to get hints about pathslibfind_pkg_check_modules(Magick++_PKGCONF ImageMagick++) # Include dirfind_path(Magick++_INCLUDE_DIR NAMES Magick++.h PATHS $&#123;Magick++_PKGCONF_INCLUDE_DIRS&#125;) # Finally the library itselffind_library(Magick++_LIBRARY NAMES Magick++ PATHS $&#123;Magick++_PKGCONF_LIBRARY_DIRS&#125;) # Set the include dir variables and the libraries and let libfind_process do the rest.# NOTE: Singular variables for this library, plural for libraries this this lib depends on.set(Magick++_PROCESS_INCLUDES Magick++_INCLUDE_DIR Magick_INCLUDE_DIRS)set(Magick++_PROCESS_LIBS Magick++_LIBRARY Magick_LIBRARIES)libfind_process(Magick++)","tags":[{"name":"机器人软件构造","slug":"机器人软件构造","permalink":"https://ZhenshengLee.github.io/tags/机器人软件构造/"}]},{"title":"【深度学习】Caffe-opencl-1构建","date":"2016-10-02T11:34:41.000Z","path":"2016/10/02/161002-Caffe-opencl-1构建/","text":"前言 自己脑残，当年买了个A卡，有点兴趣，构建了一下Caffe-opencl 重要经验：重新构建一定要make clean [TOC] 参考 Problem with greenteaGithub-caffe-openclTestSharedWeightsUpdate Test Failed 记录安装私有显卡驱动程序 到官网即可 安装显卡APPSDK 到官网即可 记住clinfo查看情况，如果没有查看到AMD APP，则按下步骤解决 sudo apt-get install fglrx fglrx-core fglrx-amdcccle fglrx-dev fglrx-pxpress 安装CUDA sudo apt-get install nvidia-cuda-toolkit 不要安装！ 安装boost sudo apt-get install libboost-all-dev 安装googletest sudo apt-get install libgtest-dev 使用ACML数学库(AMD Concurrent Mathmatical Library)先安装gfortran sudo apt-get install gfortran 查看自己CPU支持哪些指令集，本机支持SSE2，AVX，只要支持AVX或者FMA4就可以使用这个库加速以提高性能，不然就不行 cat /proc/cpuinfo | grep flags 安装ACML sudo mv ./acml6.1.0 /opt 编译时一般使用动态链接库，要使用动态链接库，需设置环境变量LD_LIBRARY_PATH If you have an SMP machine and want to take best advantage of it, link against the gfortran OpenMP version of ACML like this: 由于本机不是多处理器机器，所以使用gfortran64 到底是不是呢？多核处理器应该也是多处理器才对啊～加到变量里面再说吧！ echo ‘export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/acml6.1.0/gfortran64/lib’ &gt;&gt; ~/.bashrc echo ‘export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/acml6.1.0/gfortran64_mp/lib’ &gt;&gt; ~/.bashrc source ~/.bashrc 环境变量立即生效 示例程序在/opt/acml6.1.0/gfrotran64/examples 使用GNUMakefile进行编译 使用计时程序画图表示 sudo apt-get install gnuplot 编译时使用多线程 % make OMP_NUM_THREADS=2 编译时画时间图 % make plots You may need to edit the GNUmakefile to point at the correct location of your installed copy of the ACML, or to change compilers and flags. 安装cIBLAS(a software library containing BLAS functions written in OpenCL) git clone cd src &amp; mkdir build &amp; cd build cmake .. sudo make collect2: error: ld returned 1 exit status make[2]: * [staging/test-correctness] Error 1 make[1]: * [tests/CMakeFiles/test-correctness.dir/all] Error 2 make: * [all] Error 2 这是个BUG，去下载dev版本的clBLAS吧 还没解决。。。看帖子 检查gcc（4.8.4），CMake（2.8.12.2），Make（3.8.1）版本 检查各个依赖项的配置是否正确 OPENCL配置 无误 boost 没有设置环境变量 export BOOST_ROOT=/usr/lib/x86_64-linux-gnu gTest 已经安装好了 不仅要装clACML，也要装ACML 早就装好了 clBLAS install cmake-gui 检查cmake 输出 sudo apt-get install liblapack-dev 成功！！！ 安装在/usr/local/lib64 export CLBALS_ROOT=/usr/local/lib64 /usr/local/include 安装Caffe-opencl sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler sudo apt-get install –no-install-recommends libboost-all-dev sudo apt-get install libatlas-base-dev sudo apt-get install the python-dev sudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev compile opencl-caffe 修改Makefile.config 123456789101112# Override BLAS, use clBLAS insead of ViennaclBLAS.USE_CLBLAS := 1# Custom clBLAS lib and include directories.CLBLAS_INCLUDE := /usr/local/includeCLBLAS_LIB := /usr/local/lib64...# CUDA directory contains bin/ and lib/ directories that we need.# CUDA_DIR := /usr/local/cuda# On Ubuntu 14.04, if cuda tools are installed via# \"sudo apt-get install nvidia-cuda-toolkit\" then use this instead:CUDA_DIR := /usr make make runtest 出错，发现还是GREENTEA的问题，决定重新安装Vienna库（/usr/local/include/） 记住，重新构建一定要make clean 还有一个测试错误 That’s ok, it’s not actually a fail, the epsilon-distance between “is” and “should” is just a bit bigger than the test setting appreciates. 这只是计算误差而已，没有问题！ 大功告成，开始使用 mnist实例1234cd ./caffe-opencldata/mnist/get_mnist.shexamples/mnist/create_mnist.shexamples/mnist/train_lenet.sh","tags":[{"name":"机器人软件设计","slug":"机器人软件设计","permalink":"https://ZhenshengLee.github.io/tags/机器人软件设计/"}]},{"title":"【库】Cpp常用库集合","date":"2016-10-02T03:35:06.000Z","path":"2016/10/02/161002-Cpp常用库集合/","text":"[TOC] 前言 没事儿到网上知乎了一下，有时间就积累，学习吧 清单标准库 C/C++ 标准库 必须掌握 STL/Boost 必须掌握 POSIX C规范 必须掌握 界面 Qt 界面库 数据库 SQLite 一个完全嵌入式的，功能齐全的关系数据库，只有几百K，完全可以包含在项目中 MongoDB OTL 知乎网友推荐 异步/网络 boost.asio ZeroMQ 知乎推荐 muduo 并发多线程 OpenCL OpenMP 数学 Gurobi 优化问题解算 GNU Scientific Library 最优化，排序，线性代数，稀疏矩阵 MKL 来自Intel NLopt 有约束类问题用这个最优化包不错 FFTW 用一维或多维计算DFT的库 动力学仿真 Box2D 2d游戏物理引擎 Bullet 3d的游戏物理引擎 ODE 开源，高性能，刚体动力学仿真 Simbody 模拟关节生物力学，如人体骨骼 机器人 MOOS-lvp 提供机器人平台的自主权，主攻海洋车辆 MRPT Moblie Robot Programming Toolkit，五脏俱全，但跟ROS比不得 对NI设备提供直接支持 Robotics Library 机器人动力学，运动规划和控制，跟Orocos的不同是这个库自带前端 重要特点是官方支持在Windows中构建！ RobWorkProject 一个大学出的算法集合，主要目标是学生，貌似适合学习源代码！ 机器学习 Caffe Shark Dlib 计算机图形 HDK 3D库 日志库 log4cpp easylogging++ 知乎推荐 glog Google出品 其他 protobuf 序列化工具 Folly Facebook开发和使用的库","tags":[{"name":"机器人软件设计","slug":"机器人软件设计","permalink":"https://ZhenshengLee.github.io/tags/机器人软件设计/"}]},{"title":"草稿：机器人协作平台软件建模，设计与实现","date":"2016-09-30T01:14:50.000Z","path":"2016/09/30/160808协作平台软件建模与设计/","text":"[TOC] 0 摘要 （第一章）探讨和综述了机器人系统设计中的复用，包括设计方法级别复用（各种设计方法和原则）和体系结构级别复用（传统的智能组织到基于组件机器人工程）。介绍基于组件机器人工程（软总线技术CORBA和组件库技术） （第一章）介绍机器人系统设计中的一个重要模块，人机协作系统。 （第二章）基础知识。 （第三，四章）基于功能分析和UML模型对机器人协作系统软件进行建模和设计 （第五章）基于LabVIEW对软件进行实现 （第六章）针对当前软件的扩展性，提出一种软件设计参考模型。 1 绪论1.1 机器人系统开发概述 如何科学而高效地设计机器人系统，一直是业界的热点问题。由于缺乏有效的软件集成方式，开发者在不断地重复“造轮子”，导致开发效率低下。一直以来，学者们不断在探索在机器人系统设计中的复用，包括方法复用和体系结构复用，在方法复用的探索上，研究者们不断提出新的系统化的机器人设计方法，在体系结构复用方面，研究者们期望能够得到一个通用的系统架构。（Wei and Jiachen et al., 2011） 分析领域内的复用 关于如何设计机器人系统，学者们从各个角度阐述了不同观点。在设计方法学上，一直存在着两种传统观点：基于符号处理的自顶向下方法和基于生物学原则的自底向上方法（Jones and Roth, 2004），不过当前的趋势是两种方法深度结合的混合设计方法。Pfeier（Pfeifer and Iida et al., 2005）在其论文中提出了一系列机器人的设计原则，包括通用的设计流程原则和具体的智能体设计原则两大类，在设计流程方面的原则包括“在构建中理解（Understanding by building）”的合成方法原则，紧急原则（系统应具有适应性，如能够在非正常情况下工作）等；智能体设计原则包括三构造原则（设计智能系统必须将环境，任务，智能体考虑在内），并行低耦合原则（与环境的交互任务必须是并行的，异步的，部分自主的，低耦合的）等等，为我们设计新一代机器人系统提供了指导。Yavuz提出了一种面向功能的概念分析方法来设计智能移动机器人，其主要流程分为：1）多学科功能分析；2）将功能分解至合适的细粒度；3）对于每一个子功能，找出多种实现手段和可替代功能；4）设计总体模型。其论文给出了一个案例，在案例中把机器人的功能分为三个大类：移动性（Mobility），导航（Navigation）和自主（Autonomy），同时考虑到机器人产品的商品性，提供了五个非功能性设计需求：简单的总体结构（Simple overall structure）；高效率（Cost effective）；鲁棒性的结构（Robust structure）；智能和具适应性的行为（Intelligent and adaptive behavior）；操作可靠（Reliable operation）。接下来使用FD树对这些需求进行分解，并选择使用机械，电子或软件的方法进行实现，最后给出一个总体的结构图。这种方法的优点是概念清晰，在功能较少的情况下设计简单，不过当系统变得复杂之后，设计仍然面临很多困难。2010年OROCOS的作者提出了以关注点分离为核心的BRICS设计原则并作为机器人开发最佳实践，BRICS提出了“5C模型”，即通信（Communication），计算（Computation），协调（Coordinator），配置（Configuration），构造（Composition）在设计和实现过程中得到分离，给予我们许多有益的启示。 设计领域内的复用 架构是构建复杂智能系统的基石，好的架构可以清晰描述如何将智能系统分解为子系统。关于寻求通用的系统架构，在20世纪90年代，学者们的关注点在于整体构建机器人的智能，提出了三种机器人范式：慎思式，反应式和混合范式（Arkin, 1998），随着计算机性能的快速发展，同时具有慎思式和反应式优点的混合范式已经称为主流。到21世纪初，不同厂商的机电设备，模块的不通用性已经成为制约机器人开发成本和设计周期的主要障碍，学者们的关注点从机器人系统的整体构建转移到基于组件技术的中间件研究，代表性成果包括软总线技术标准CORBA（Common Object Request Broke Architecture）（OMG）和组件库OROCOS（参考文献）。CORBA支持异构平台下对象的可互操作性和移植性方面具有很大开放性与灵活性，该标准主要特点是实现了软总线结构，通过功能抽象，屏蔽和隐藏底层诸如操作系统、开发语言和具体技术、协议等细节差异，形成一套统一的接口描述，从而解除了各个组件之间的紧密的耦合性；同时将各类应用模块按总线规范封装成组件，插入总线即可实现集成运行。OROCOS项目具体由四个C++组件库组成：实时工具集（RTT），运动学与动力学算法集（KDL），贝叶斯过滤库（BFL）与OROCOS组件库（OCL）：（1）实时工具集不仅是一个应用程序，还为机器人系统开发人员提供了大量的组件化应用案例；（2）运动与动力学组件是一个C++的函数库，提供了实时的动力学约束计算服务；（3）贝叶斯过滤库提供了一种专有的应用算法库，是由动态贝叶斯网络理论推导出的。这个理论可用于递归信息处理及基于贝叶斯规则的算法评估，例如卡尔曼滤波，粒子滤波算法等；（4）OROCOS组件库提供了一些典型的控制模块，如硬件接口模块，控制模块及模块的管理功能组件。 基于组件机器人工程 基于组件的软件设计，综合了设计方法层次和体系结构层次的软件复用（需要文献支撑），其理念受到业界广泛应用，历年来不断出现的机器人中间件（FINROC，2012）（GenoM3，2010）（OPRoS，2010），以ROS（机器人操作系统，2011）为代表，能够有效屏蔽操作系统、开发语言和网络协议的差异，为机器人开发提供多种通信和服务机制，是解决机器人组件化设计、消除机器人系统异构性问题的有效途径之一，目前已成为国际机器人研究的热点领域。（接下来介绍2010年基于组件机器人工程（Component-based robotic engineering）的提出）（Brugali and Shakhimardanov, 2010）（文献待阅读） 1.2 人机协作系统1.2.1 人机协作系统的提出 智能移动机器人正在以惊人的关注度走进人类生产生活的各个方面，这已成为学界和工业界的共识。为了完成复杂的任务，机器人不仅仅需要在非结构环境下安全高效工作，而且需要与人有较高层次的合作与沟通。历史上移动机器人与人的交互模型主要有三种，第一种是遥操作，即人与机器人为主从关系，机器人实际上是人的工具，人与机器人构成控制闭环，人的作用就是控制器。这种交互方式的不足在于；1）如果工作人员离岗，机器人就停止工作，即人需要长时间在线；2）由于人控制的精确性和稳定性远远不如机器，机器人的工作能力被人所弱化；3）如果系统延时较大，如发生紧急事故，人不能立即操作机器人解决问题。第二种交互模型为监督控制，即人传递给机器人一个简单具体的指令清单，机器人按照指令清单执行动作，人主要进行机器人监控和流程控制。这种交互模型的不足在于1）由于机器人及所处环境未知且复杂，机器人指令清单设计困难2）非结构环境下难以保证机器人动作执行正确。第三种交互模型为全自主控制，人只需传递机器人一个抽象的任务目标，机器人借助人工智能技术自主感知环境，进行任务规划和执行。这种交互模型的不足在于，当前的人工智能技术（尽管飞速发展）与人类智能的差距太大，但技术还远未成熟。三种交互方式的控制结构示意图如下所示(徐坤, 2009) 图取自他人论文，尝试修改或者新建一套图 随着基于行为移动机器人研究的兴起，机器人自主性不断提升，人与机器人交互模型也相应有了新的发展——人机协作（HRC）。在这种模式下，人与机器人合作完成工作任务，机器人并不是人类的工具而是伙伴，能够跟人进行沟通，思考人类的意图，主动向人类提问或寻求帮助，将人类作为外界的消息来源，更好地完成目标。人机协作，作为新的人机交互模式，拥有极其广阔的研究价值 需要最新文献支持。 1.2.2 人机协作系统的特点（王挺, 2004） 在人机协作系统中，人通过某种方式参与到系统的感知，判断，决策过程中。与通常的半自主机器人不同，人类智能作为智能机器人系统的一个智能模块，和其他功能模块一样具有特点的功能与接口，由于其拥有所有环境信息，所以可认为具有最高级的智能。需要注意的是，人类智能无法直接作用于机器人的执行机构，而是需要与机器智能协作。 具体来讲，人类智能模块接收来自于机器人的系统状态信息、传感器环境信息和一定条件下可以获得的操作者直接观察到的环境信息, 对这些信息进行整理、抽取、分析、合并得到用以辅助机器智能操作的输出, 输出量应该在机器智能算法遇到局限时起到辅助和指导作用。按照传统的三层递阶体系结构分类，人类智能位于组织层，机器智能跨越组织层和协调层，是某种特定形式的人工智能算法，它接收系统状态信息，传感器环境信息和来自于人类智能模块的指导性输入，经运算得到相应的控制量输出，送给位于执行层的任务分解单元。在大多数情况下机器人可以凭借自身的智能算法完成移动功能，只有当机器人遇到复杂环境无法完全根据自身的算法获得有效输出的时候，人类智能模块的指导性输入量才被引入。体系结构示意图如下。 图取自他人论文 当然作为适当的功能保留，操作者应当具备对机器人的直接指令操作能力，并在任何时候对于机器人系统享有高于机器智能的优先控制权，但这时人机系统便退化成为人机交互系统(半自主系统)(体系结构示意图如下)，从图中可以看出人机系统与人机交互系统(半自主系统)的另一个区别在于前者人与协层交互，后者人与执行层交互。 图取自他人论文 1.3 本项目背景和意义1.3.1 背景 智能移动机器人正在以惊人的关注度走进人类生产生活的各个方面，这已成对为学界和工业界的共识。人们机器人抱有极大的热情和期待，例如期待机器人能够代替人类去危险、有毒、有害的场所实施灾害救援任务，能够进入太空或其它星球完成太空探索任务，能够在我们步入老龄社会时承担助老任务，能够帮助残疾人实现生活自理……。但目前的科学技术水平距离人们的期待还有很长的路要走，机器人没有办法独立完成这些任务。本项目以“人”与“机器人”的协作为出发点，试图通过协作，充分发挥人与机器人各自的优势，以实际可行的方式，在一定程度上实现人们对机器人的期待。本项目充分利用机器人的精准、“钢铁之躯”和人类在意识、决策上的优势，实现任何单独一方难以完成的任务，具有极大的应用前景。 大量文献资料表明，人机协作乃至对等协作的人机交互方式是移动机器人控制的研究热点和发展方向。对机器人人机协作平台软件的研制，将有效提高机器人的工作效率和能力，进而提高机器人的自主性；采用新的软件复用方法和工具，将有望产生新的可复用的软件体系架构和软件开发过程模型，为以后的研究打好基础和提供指导，为同行提供可借鉴的经验。 本课题受国家“973”计划课题“核电站紧急救灾机器人的主从控制和自律协同”资助（编号2013CB0S35504）。 1.3.2 主要创新点 在机器人软件设计不成熟的背景下，基于UML规范对机器人协作平台软件进行建模和设计。基于模型的设计通用性好，可向同行提供有价值经验。 创新性的使用Actor编程模型对软件进行详细设计，软件模块化，扩展性能好。 提出一个机器人协作平台软件的通用参考模型，有望实现多机器人人机协作平台。 不仅提供了一种模型表示，还给出了实际开发过程。 1.4 人机系统相关工作有待文献查取和写作 2 基础2.1 本项目概述暂时摆两张图 2.2 LabVIEW2.2.1 LabVIEW执行系统（多线程，多任务） 在LabVIEW中，VI文件是基本的程序运行单元，一个VI包括前面板和后面板，开发者通过在前面板上放置控件，在后面板上进行图形编程的方式，制作虚拟仪器程序。每一个VI应用程序可以执行特定的任务，并拥有完整的人机交互界面。本节将介绍LabVIEW非常重要的特性——自动多线程，LabVIEW自动将每个应用程序分解为多个执行线程。本节先介绍LabVIEW单个应用程序的自动多线程原理，然后介绍VI的线程模型，最后介绍LabVIEW中的多任务。 2.2.1.1 LabVIEW的VI自动多线程以下内容为摘抄，待修改 线程管理的复杂任务内化在LabVIEW执行系统之中。 所有线程管理的复杂任务在LabVIEW执行系统中都是透明的。基于文本程序设计的程序员必须学习新的复杂的编程方法来创建多线程应用程序。但是所有LabVIEW应用程序都可自动进行多线程化，无需修改任何代码。 除了操作系统的抢占式多任务处理，LabVIEW还采用了协同式多任务系统。在编译过程中，LabVIEW将分析VI查找可以同时运行的节点组合，这种节点组合也称为程序块。每个优先级和执行系统的组合都有一个运行队列数据结构，以保留哪些程序块能够一起运行。执行系统在激活一个线程的同时会从运行队列中重新找回并执行这个程序块。执行系统完成执行后，将存储其他的队列中符合输入条件的程序块，允许程序框图在4个可执行线程中的任何一个线程上执行。如果程序框图包含足够的并行机制，它可以在所有线程上同时执行。 LabVIEW不能永久地给一个特定的线程分配程序块代码。下次运行VI时，LabVIEW将以不同的线程执行程序块。 下列程序框图上的红色长方形显示了LabVIEW如何将节点组合为程序块。 在该例中，程序框图由三个程序块组成，输入控件的程序块与显示控件的程序块是一样的。因此，该程序块在两个时间点执行。程序块在执行前后会进入休眠或延迟状态。左边第一个程序块开始执行后，第一个程序块即开始休眠，其他两个For循环程序块开始执行。VI准备开始执行显示控件程序块时，左右两个程序块停止休眠。 2.2.1.2 单个应用程序的线程模型 根据上一节的原理，VI根据实际编写的代码，自动分配个多个线程完成任务，这在多核处理器电脑中会带来性能提升。那么每一个VI中到底包含多少线程？ LabVIEW分配大致三类型线程： 1个UI线程，用于屏幕刷新和键盘鼠标输入。这个线程同时也用于特定VI的执行，譬如属性节点，非安全线程和DLL等。 内部线程，LabVIEW内部使用。如一对定时线程。 20个执行线程(每一个CPU)。 可选线程。如果使用ActiveX客户端工作，那么还会分配更多的线程。 关于20个执行线程，LabVIEW有5个 “执行系统”, 并且每个执行系统分4个不同等级分配线程。于是总共有20个线程（并且没有包含UI线程，也是用来执行的）。这5个执行子系统包括：Standard，I/O，DAQ，Other 1，Other 2，示意图如下所示。关于各个子系统的职能以及更多信息，请参考文献（Bitter and Mohiuddin et al., 2006） 2.2.1.3 LabVIEW中的多任务介绍在LabVIEW中的线程，进程间通信方式，参考《LabVIEW宝典》 2.2.2 LabVIEW软件开发（项目管理，面向对象，CBSE扩展性） LabVIEW不仅仅用来编写概念验证代码和一次性测量程序，作为一种成熟的编程语言，依然支持复杂的软件工程实现各种应用。本节阐述了使用LabVIEW进行更复杂编程时会用到的功能特性。主要包括LabVIEW项目管理器，面向对象编程，和软件扩展性三个方面。 在本文的接下来部分，我们将通过LabVIEW面向对象编程和操作者框架来展示如何使用LabVIEW来构建大型程序。 都是教科书上的内容，先贴几张图 2.2.2.1 项目管理器2.2.2.2 面向对象2.2.2.3 扩展性暂时摆图一张 3 机器人软件的分析建模 本项目将移动机器人软件开发过程建模为7个阶段：【需求建模（需求分析）】用例建模；数据流建模；【设计建模】早期设计；体系结构设计；构件选择和复用；构件精化；【软件实现】系统实现阶段。在第四，五，六章依次进行介绍。本章介绍分析建模部分的两个阶段：早期需求分析和结构化分析。 3.1 早期需求分析 早期需求分析的主要工作是基于用户场景产生用例模型，如果需要还应使用诸如活动图，泳道图等作为补充用例。本项目根据移动机器人的应用场景，撰写用户场景叙事，最终产生用例图和用例描述。 限于篇幅限制，只提供顶层用例图和一个用例的用例文档，其他查阅外部文档 3.1.1 用户场景叙事 机器人监管者（Supervisor）在本地工作站上，通过无线局域网与远程的P3AT移动机器人（P3-AT Mobile Robot）进行协作，完成巡逻，环境监测，危险排除等任务。具体来讲，机器人监管者可以使用两种方式与机器人进行协作：手动控制（Manual Synergetic Control）和语音控制（Voice Synergetic Control），为了更好地与机器人进行协作，机器人在监管者面前应该是透明的，即机器人本体状态及周围环境信息应实时展现给监管者。 在手动控制中，监管者在本地工作站上使用操纵杆对机器人进行远程控制，监管者能够直接控制机器人自身移动，操作机械臂等执行机构，监管者也可以在地图上点击一个目标点，命令机器人到达该点位置；在语音交互中，监管者对手机讲述中文语音，将声音信号传递给机器人，机器人收到语音信号后执行对应的任务，如“向前走五米”命令。 机器人应做到较底层的行为自主，能够做到自我保护，环境识别与推理，路径规划等。机器人能够在较高的思维抽象层次与监管者进行协作。机器人在工作过程中，监管者能够随时打断机器人，获得最终控制权。 在监管者向机器人发送协作指令的同时，机器人将自身的状态信息和采集到的周围环境信息传输回本地工作站，本地工作站对其进行建模，通过人机交互界面将信息可视化。监管者在本地工作站上将能够清晰地了解机器人的情况。 3.1.2 顶层用例图见图Top Level Use Case.pdf 3.1.3 “语音协作控制”用例文档 用例名：语音协作控制 概述：监管者在本地工作站，使用安卓手机输入语音信号，对机器人进行远程控制。 参与者：监管者和P3-AT机器人 前置条件：工作站与机器人连接成功 主序列： 机器人与监管者交互定位 监管员要求进行语音协作控制 监管者使用手机输入进行语音信号录入，手机端将语音信号解释为中文命令，录入到本地工作站 本地工作站结合机器人状态数据，对命令进行初步分析，得到指令的抽象信息（类型，参数大小等），验证命令的合法性 如果命令合法，本地工作站对命令进行解释（翻译？），解释成机器人能够理解或直接执行的指令 如果解释成功，本地工作站将解释好的指令传递给远程机器人 远程机器人对指令进行执行，并在人机交互界面显示命令执行情况 如果命令执行情况正常，则在命令执行完毕后在人机交互界面显示执行结束情况 可替换序列： 步骤5：如果命令不合法，工作站人机交互界面上予以显示并停止，并要求监管者修改或者重新输入命令 步骤6：如果命令解释失败，工作站人机交互界面上予以显示并停止，并要求监管者检查命令或重新输入命令 步骤8：如果命令执行过程中出现失败，则在人机交互界面上予以显示并停止，并要求监管者重新输入命令。 步骤2-8：监管者放弃语音协作控制，控制结束。 3.2 面向数据流建模 数据流模型本是软件结构化分析方法的核心步骤，它从数据传递和加工的角度，刻画数据对象通过系统时如何转换数据。在本项目中其作为主要的需求分析表达方式，以提供对系统需求和流程的补充认识，在后面可以看到，数据流模型非常方便地映射为LabVIEW程序结构，使得软件开发效率大大提升。数据流模型的主要工作产品是数据流图（DFD） 3.2.1 为什么使用面向流程的建模方法 1.符合机器人结构的基本范式，便于从基本范式映射到软件模型。根据文献[Murphy.2001]，机器人的各种控制结构，都是由三种基元构成，即感知、规划、执行，各种机器人结构，都是三种基元经过不同抽象层次的分解和相互作用的结构。一般来讲，感知基元对传感器信息进行处理，生成感知/认知信息，规划基元对感知/认知信息进行处理，生成机器人能够直接执行的指令，而执行基元对指令进行处理，生成更加具体的执行器指令。整个过程可以非常直观地用数据流图表示 2.数据流模型可以直接映射到LabVIEW程序结构。LabVIEW开发平台使用图形化编程语言G语言，G语言设计的核心就是对数据流的表示[Hugo.1998]。本文提供环境图（顶层DFD）、一个分解举例和底层DFD 3.2.2 顶层数据流模型 DFD采取了系统的输入-处理-输出的观点，也就是说，流入软件的数据对象，经由处理元素变换，最后以结果数据对象的形式流出软件。带标记的箭头表示数据对象，圆圈表示转换。DFD使用分层的方式表示，即第一个数据流模型表示整个系统，随后每个后续层提供更多的细节[Pressman.2005]。 顶层数据流模型（环境图）将整个软件系统描述为一个转换，用圆圈表示，外部实体（方框）产生系统所使用的信息，带标记的箭头代表数据对象。 顶层数据流模型见Context Diagram.pdf 3.2.3 第一层数据流模型 根据用例模型，我们将DFD扩展到第一层。DFD的扩展遵循传统上对机器人结构的认识，即感知、规划和执行。 第一层DFD见First-Level DFD.pdf 3.2.4 数据流模型的精化 接下来应该对DFD进行求精，以获得更多需求信息，直到每一个泡泡都执行某一个单一的功能，这样该功能就很容易地成为一个程序构件。这里以Interacting management处理的精化为例，直观地，用户与软件交互按照目的划分，分为配置定位、配置地图、配置机器人、停止和启动四个方面，按照这种逻辑精化，得到第二层DFD。 DFD精化例子见Management.pdf 3.2.5 第二层DFD 进行DFD分解要注重每一个变换都要有相对高的内聚性，对每一个变换进行精化后的第二层DFD如下。 第二层DFD见Lowest-Level DFD.pdf 4-机器人软件的设计建模 基于并发构件的软件体系结构 使用像“软件系统的软件体系结构被设计成一个基于分布式构件的软件体系结构”的句式是否具有说服力？ 在上一章中，已经使用面向流程的方法进行了需求分析，通过构建数据流图并进行精化，软件系统的每一个功能已经转化成DFD中的一个个变换和数据流动，接下来的设计建模过程，将基于需求分析模型设计软件体系结构，给出更多软件系统的表示信息，包括通信图，顺序图和状态图等。 本项目中， “机器人协作系统”被设计为一个基于并发构件的，分层控制的软件体系结构。 本项目中，设计建模的第一步就是将分析模型（主要为DFD）精化映射为构件模型，接下来设计构件间通信消息及通信消息模式，给出更多UML图形表示。【这里的DFD相当于“COMET”方法中设计子系统之前的集成通信图】 4.1 从数据流图到软件子系统的映射 在设计构件之前，需要先设计软件子系统， 在分析建模阶段，我们通过功能分解描绘了软件系统的逻辑模型，在设计建模阶段，我们将基于此设计“机器人协作软件系统”的各个子系统，设计目标是让每个子系统都能负责执行一个相对独立的功能。这样，当定义好子系统之间的接口之后，就可以独立进行各个子系统的设计了。 4.1.1 关注点分离 在子系统设计时需要解决关注点分离问题，即让不同的子系统关注不同的关注点，目的是让子系统的独立性更好。根据文献[Gomaa. 2011]，考虑不同的子系统组织准则，可以将软件系统分解为客户端子系统，用户交互子系统，服务子系统，控制子系统，协调者子系统，输入/输出子系统等，这些子系统组织准则同样可以应用于构件设计。 下面简要介绍各种子系统的特点 客户端子系统：一个客户端子系统是一个或多个服务的请求者。客户端子系统包括用户交互子系统，控制子系统和输入/输出子系统。 用户交互子系统：用户交互子系统提供用户接口，并且充当一个客户端/服务系统中的客户端角色，提供用户访问服务。 服务子系统：服务子系统为客户端子系统提供服务。服务子系统并不会发出任何请求，而是对来自客户端子系统的请求进行响应。 控制子系统：一个控制子系统控制系统中的一个特定部分。控制子系统接收来自外部环境的输入，产生面向外部环境的输出，其中通常没有人工干预。一个控制子系统通常是状态相关的。一个控制子系统可以从另一个给予其总体方向的子系统那里接收一些高层指令，然后持续地或者以按需的方式向其他结点提供低层控制或者发送状态信息。 协调者子系统：协调者子系统协调其他子系统的执行，例如控制子系统或服务子系统。所以协调者子系统相应地分成这两类：协调控制子系统的子系统和协调服务子系统的子系统。 输入/输出子系统：一个输入，输出或输入/输出子系统是一个代表其他子系统执行输入和/或输出操作的子系统，通常由一个或更多的设备接口对象组成，并且还可能包括提供本地化控制的控制对象和存储本地数据的实体对象。 本文将根据以上原则将数据流图中的各个流程转换为独立的软件子系统，在下一小节进行控制模式的选择之后，添加相应的控制子系统。 4.1.2 层次化的控制模式 并发软件体系结构中的控制模式主要包括集中式，分布式和层次化控制体系结构 集中式控制模式：集中式控制体系结构中只包含一个控制子系统。从概念上来说控制构件要执行一个状态图以总控全局并管理整个系统的行为顺序。 分布式控制模式：分布式控制体系结构中包含多个控制子系统。控制分布在各个控制模块中，控制模块通过点对点的通信实现重要事件的通知，也通过与集中式控制模式中类似的方式与外部环境交互。 层次化控制模式包含多个控制子系统，不过与分布式控制模式不同，存在一个协调者子系统，通过协调所有控制模块完成整个系统的控制。协调者提供高层控制，包括直接与各个控制模块进行通信并且决定各个控制模块的下一步动作，同时协调者也从控制模块中接收状态信息。 由于本项目需要处理多个输入输出，且需要一定的扩展性，所以采用层次化控制模式。 4.1.3 初始软件子系统图 根据前两小节的子系统组织准则，将数据流图转映射为如下所示的软件子系统图，可以确定以下子系统： 。。。 。。。 初始软件子系统图见Components-1st-Refinement-final.pdf最后不能用构件图来画这几张图 *不难看出，这里得到的子系统图只是数据流图和控制构件的简单组合，“碎片化”严重，存在着多种子系统执行类似功能，以及控制构件控制单一构件的情况。在下一节基于构件的软件体系结构设计中，将针对这两种情况，对当前子系统图进行精化，生成构件图。 4.2 基于并发构件的体系结构 软件体系结构的设计，主要考虑系统的静态结构和动态结构。本节将基于前面生成的软件子系统图，生成静态的软件构件图即构件图，和动态的软件体系结构图即通信图。 软件体系结构的静态结构设计，通常都会应用得到广泛接受的基于构件的思想，本文也不例外。一个基于构件的软件体系结构由多个构件组成，其中每个构件相互独立且封装了信息，在外部暴露接口，通过接口与其他构件进行通信，所有与其他构件进行通信所需要的信息都包含在接口之中，并且接口与实现相分离。构件之间使用预先定义好的通信模式进行通信。良好设计的构件应能够在后续设计中得到复用。 由于本项目机器人协作系统涉及多个输入输出，所以需要开发一个并发的软件体系结构。这样在软件体系结构中，每一个构件都可以是并发的，进而可以是分布式的，软件构件可以部署到不同的物理结点上，这些特点可以极大增强软件体系结构的扩展性。 在本项目的基于构件的开发方法中，每一个子系统都被设计成一个分布式的独立构件。根据一定原则，多个构件可以组合得到复合构件。本文将对上节产生的子系统图进行精化，生成构件图，描述其静态结构（结构图）和动态结构（高层通信图）。 4.2.1 子系统图的精化——体系结构的静态视图复合构件的组织原则：地理位置一致，功能类似 上一节生成了作为初始软件体系结构的软件子系统图并提出了相应问题。这一节将针对这些问题对软件体系结构进行精化，生成最后的构件图。 针对前一种情况，应将执行类似功能的子系统合并，虽适当降低了内聚性，但使得构件组织结构更合理；针对后一种情况，只需把控制子系统省略掉即可。 具体的精化步骤如下： 。。。 。。。 最后生成的构件图如下 软件子系统图见Components-2nd-Refinement-final.pdf 4.2.2 高层通信图——体系结构的动态视图 通信图是描述软件体系结构动态视图的主要方式，本节先简要介绍软件体系结构的主要通信模式，然后介绍本项目中构件与构件之间的通信方式，设计确定每条消息的名称和参数（接口规约）和精确语义。 4.2.2.1 体系结构通信模式 在从分析模型到设计模型的过渡中，最重要的决策之一就是与子系统之间需要哪种类型的消息通信，在分布式系统中，常见的消息通信模式如下： 异步（松耦合）消息通信：通过异步消息通信模式，生产者构件发送一条消息给消费者构件并且不等待其回复，生产者会继续执行，因为它要么不需要一个回复，要么在收到回复之前还要执行一些其他的功能。消费者收到消息，如果消费者正在处理其他事情，那么该消息会进入等待队列。由于生产者和消费者构件是异步执行的，因此可以在生产者和消费者之间建立一个先进先出的消息队列。当消费者请求消息但消息却没有到达时，该消费者会被挂起，当消息到达后，消费者会被唤醒继续工作。在分布式的环境中，任何可能会提高灵活性的地方都可能使用异步消息通信模式。该方法也可以用在发送者不需要接受者进行回复的情况下。 带回复的同步（紧耦合）消息通信：在这种通信模式下，生产者向消费者发送消息并等待消费者的答复，如果有多个生产者向消费者发送消息请求，则在消费者端建立一个消息队列。 不带回复的同步（紧耦合）消息通信：在这种通信模式下，消息生产者向消息消费者发送消息，并等待消息被消费者接收。当消息到达时，消费者接收消息并释放生产者，随后生产者和消费者一起继续执行消息收发过程。如果没有消息到来，消费者会挂起。 4.2.2.2 高层通信图设计 在前面的分析模型中，已经通过数据流图展现了信息以及在软件模块之间流动的方向，也就基本确定了模块间消息的类型。如下： 。。。此处写上软件设计中的消息类型 。。。 。。。 根据具体的项目需要，每条消息的接口规约如下： 。。。 。。。 。。。 最后的高层通信图如图所示。 4.2.3 构件间交互图——体系结构的动态视图此处介绍各个用例的顺序图 。。。 4.3 软件构件部署 一个典型的系统的软件部署如图所示，每一个构件都被分配到一个特定的物理结点，结点之间通过互联网连接。具体情况如下： 。。。 。。。 。。。 5-软件构件的设计与实现 在体系结构设计完成之后，就开始进行构件级设计和编程实现，在本项目中，由于软件体系结构的分布式并发特性，我们创新性地使用LabVIEW开发平台及其多进程异步通信框架Actor Framework对机器人协作软件进行实现，在本节中，将先对LabVIEW开发平台及Actor编程模型做简单介绍，然后根据之前的设计模型进行进一步设计和详细编程实现，模型进一步设计包括构件模型映射为LabVIEW中的Actor编程模型，详细编程实现包括Actor实现及其各个通信模式的实现。 5.1 Actor编程模型的应用5.1.1 LabVIEW Actor Framework LabVIEW于1986年由美国国家仪器公司发布，是一个虚拟仪器开发环境，其本质用途是为硬件提供可视化和控制接口。LabVIEW拥有独特的G语言，这种特性同时提供了人机交互和源代码（Dr. Sumathi and Prof. Surekha, 2007），给开发者提供了巨大的便利，关于LabVIEW的使用，请参考文献（Bitter and Mohiuddin et al., 2006），下面介绍本文主要使用的LabVIEW Actor Framework，一个基于面向对象的程序模板，其实现了Actor编程模型，提供了多进程通信的框架。 Actor模型，于1973年被提出（Hewitt and Bishop et al., 1973），是一种并发运算上的模型，Actor是一种程序上的抽象概念，被视为并发运算的基本单元，当一个Actor接收到一则消息，它可以做出一些决策、创建更多的Actor、发送更多的消息、决定要如何回应接下来的消息。LabVIEW Actor Framework（操作者框架）是Actor模型在LabVIEW上的实现。操作者框架专为多进程程序设计，为了增强代码复用使用了面向对象编程，其模板提供了基本功能，包括创建操作者，创建消息，定义消息的响应函数，关于操作者框架的详细使用，请参考官方文档（。。。），本文接下来将对操作者框架进行概念性阐释，在下一节将对机器人协作系统软件进行映射。考虑是否引入1973年的Actor Model，只将LabVIEW Actor Framework阐述为一种编程框架 5.1.1.1 操作者框架概述 “操作者框架”由操作者和消息构成。消息在消息队列中传输。为减少出错和提高应用程序的可靠性，“操作者框架”限制了能够互相发送消息的操作者。 在这儿，我们利用LabVIEW自带示例项目进行解释，该示例项目包括三个操作者：顶层操作者，Alpha操作者和Beta操作者。 5.1.1.2 操作者及消息 操作者是LabVIEW类，代表某个任务的状态。所有操作者类均从LabVIEW中的“操作者”类继承。该类由三个主要部分构成： 操作者的核心VI－核心VI是一个特定命名的方法（“操作者核心”），用来定义操作者的连续行为。该方法定义了所有操作者的消息处理行为。该类的子孙类重写方法以显示操作者的用户界面、添加并行循环和启动嵌套操作者。 操作者的特定方法－这些VI是LabVIEW类的成员VI，用于定义操作者。通常每个方法对应于操作者能够执行的一个任务。祖先类（“操作者”类）包含几个专门设计用于被子孙类重写的方法。 操作者的消息－消息是一个LabVIEW类，定义了操作者能够接收的指令和作出响应的方式。其他操作者将这些消息发送至一个操作者，以便让操作者调用其中的一个方法。在“操作者框架”基础上创建应用程序时，通常需要为操作者的每个方法定义一个消息。所有消息均从LabVIEW中的“消息”类继承。 例如，下图显示的项目库包含一个操作者Alpha（Alpha类）和一个消息(Alpha任务消息类)。 下面介绍各个文件： 操作者的核心VI是操作者核心。该方法重写其祖先的“操作者核心”方法，定义了Alpha操作者特有的连续行为。 操作者的方法是停止核心和任务。这些方法在下列条件下执行： 停止核心在Alpha操作者收到“停止”消息时执行。该方法重写“操作者”类的“停止核心”方法，用于定义Alpha操作者特有的行为。 任务在Alpha操作者收到“任务”消息时执行。该方法为Alpha操作者特有，即“操作者”类中未定义该方法。 操作者的消息包含在Alpha的消息文件夹中。该操作者仅定义一个消息，即Alpha任务消息，该消息从“消息”类继承，包含下列文件： Alpha任务消息控件是该消息携带的数据。 发送Alpha任务是其他操作者用来发送“任务”消息至Alpha操作者的VI。该VI将创建消息的一个实例并用一些数据填充消息。 执行定义了Alpha收到“任务”消息时执行的动作。本模板中，“执行”VI命令Alpha执行其“任务”方法。 示例项目类间关系图如下所示（需要加上Msg类的表示，需要重新制UML图） 5.1.1.3 操作者之间的通信 在通用Actor Model中，一个Actor能够与任一Actor进行消息通信，但在LabVIEW Actor Framework中，为了减少通信错误，默认情况下，一个操作者只能将消息发送至两种操作者： 调用方-启动X的VI（可能是一个操作者） 嵌套操作者－X启动的任何操作者 这种被限制的通信顺序称为任务树。这样的优势在于，只有一个通信路径需要管理，因此可以确保某操作在关闭之前其他操作者有机会接收其消息并作出响应。 本模板所定义的任务树如下 该图表明应用程序操作者同时启动Alpha和Beta操作者。因此，应用程序操作者称为顶层操作者，顶层操作者启动所有其他操作者。顶层操作者从一个正常VI启动。 在该任务树中，下列通信规则有效： 应用程序可将消息发送至Alpha和Beta Alpha仅能将消息发送至应用程序 Beta仅能将消息发送至应用程序 这说明Alpha和Beta无法将消息发送至对方。Alpha必须发送一个消息至应用程序，确定Beta是否需要接收该消息并采取相应的动作。同样，限制通信路径有助于写入更多易于管理和正确无误的代码。 消息通过队列发送，每一个操作者维护一个自己的队列，下图显示了两个操作者如何进行通信： 如图所示，X能够将消息发送至自身(1)和Y (2)。Y能够将消息发送至X (3)和自身(4)。尽管有四个消息可进入的方向，但只包含了两个队列。此外，两个操作者都无法释放对方的队列。相反，每个操作者释放自身的队列，作为其关闭程序的一部分。 5.1.2 本项目Actor结构 由于Actor编程模型天然的并发和模块化特性，使得机器人协作系统软件体系结构能够非常容易地转化为LabVIEW中的Actor图，其中： 。。。 。。。 。。。 软件实现的Actor任务树如图所示（这张图要改，风格不对） Actor结构图见Components-3rd-Refinement-final.pdf 最后的类图如下图所示（包括操作者类和消息类，作为两张图）这两张图要放在构件设计中 5.2 基于构件的开发——构件选择与复用 基于构件的软件工程（CBSE）强调使用可复用的软件构件来设计和构造软件系统。一方面，我们从一些标准构件库购买构件，对构件进行适应性修改后即可进行组装，另一方面，我们也需要开发新的软件构件，不过需要进行领域分析，按照标准数据结构和接口协议进行设计。本项目软件实现过程充分采用了这种思想，借助LabVIEW自带的丰富构件库进行开发，同时自己也开发出部分构件作后续使用。（component based development） 5.2.1 LabVIEW Tools Network介绍和构件清单 LabVIEW工具网络，被称为工程师的APP商店，提供了经认证的第三方附加组件，以帮助用户扩展LabVIEW系统设计软件功能，提高开发人员的效率。这些由第三方提供的软件组件主要包括以下几类： LabVIEW 插件：包括应用程序接口，代码模板，自定义控件，小工具，示例代码等 应用程序：LabVIEW环境之外的独立产品 LabVIEW工具网络所提供的组件大多可免费使用（如使用BSD许可协议），在VI Package Manager中进行搜索下载安装即可。 下图所示为VI Package Manager及本项目软件所使用的一个组件，XBox手柄控制器的工具介绍页面，下一节将使用这一标准组件，进行适应性修改后制作出本项目需要的手柄操作者。 5.2.2 构件修改及组装举例——手柄操作者的构建5.2.2.1 手柄操作者功能与通信分析5.2.2.2 核心函数编写5.2.2.3 消息函数编写5.3 构件设计5.3.1 构件设计举例-协调者构件应用状态设计模式5.3.2 协调者操作者功能与通信分析5.3.3 核心函数编写5.3.4 消息函数编写5.3.55.4 基于LabVIEW的构件（任务）间通信模式的实现除了操作者相关的都移动到前面去 5.4.1 消息队列——操作者框架提供的若干模式5.4.2 信号（在LabVIEW中的实现）5.4.3 共享变量5.4.4 Socket6-结论与展望6.1-结论6.2-未来工作——一个参考模型（功能扩展+分布式部署）附录A-ROS系统软件开发概述A.1A.2A.3参考文献 Murphy R. Introduction to AI Robotics[M]. MIT Press, 2000. Gomaa H. Software Modeling and Design: UML, Use Cases, Patterns, and Software Architectures[M]. Cambridge University Press, 2011. Pressman R S. Software Engineering: A Practioner’s Approach[M]. 7 ed. McGraw-Hill Companies, Inc, 2005. Andrade H A, Kovner S. Software synthesis from dataflow models for G and LabVIEW/sup TM[C]. IEEE, 1998. Bitter R, Mohiuddin T, Nawrocki M. LabView: Advanced Programming Techniques, Second Edition[M]. CRC Press, 2006. LabVIEW Graphical Development Platform Part I – An Open Platform for Long-Term Continuity[EB/OL]. National Instruments Corporation. 2005. Będkowski J. Mobile Robots - Control Architectures, Bio-Interfacing, Navigation, Multi Robot Motion Planning and Operator Training[M]. InTech, 2011: 402. 陈树学，刘萱. LabVIEW宝典[M]. 北京: 电子工业出版社, 2011. 徐坤. 搜救机器人人机协作行为控制研究[D]. 山东大学, 2009. 王挺，王越超. 人机系统在移动机器人平台的应用[J]. 机器人. 2004(06): 553-557. 黄志华，屠大维，赵其杰. 基于人机交互的移动服务机器人导航系统[J]. 机器人. 2009(03): 248-253. Goodrich M A, Schultz A C. Human-robot interaction: a survey[J]. Found. Trends Hum.-Comput. Interact. 2007, 1(3): 203-275. Wei X, Jiachen M, Mingli Y. Research on Building Mechanism of System for Intelligent Service Mobile Robot[M]. MOBILE ROBOTS – CONTROL ARCHITECTURES, BIO-INTERFACING, NAVIGATION, MULTI ROBOT MOTION PLANNING AND OPERATOR TRAINING, INTECTWEB.ORG, 2011. Jones J L, Roth D. Robot programming : a practical guide to behavior-based robotics[M]. McGraw-Hill, 2004: 293. Pfeifer R, Iida F, Bongard J. New robotics: Design principles for intelligent systems[J]. Artificial life. 2005, 11(1-2): 99-120. Bischoff R, Guhl T, Prassler E, et al. BRICS-Best practice in robotics[C]. VDE, 2010. Jang C, Lee S, Jung S, et al. OPRoS: A new component-based robot software platform[J]. ETRI journal. 2010, 32(5): 646-656. Domínguez-Brito A C, Santana-Jorge F J, Santana-De-La-Fe S, et al. CoolBOT: An Open Source Distributed Component Based Programming Framework for Robotics[C]. Springer, 2011. Mallet A, Pasteur C, Herrb M, et al. GenoM3: Building middleware-independent robotic components[C]. IEEE, 2010. Reichardt M, Föhst T, Berns K. Introducing finroc: A convenient real-time framework for robotics based on a systematic design approach[J]. Robotics Research Lab, Department of Computer Science, University of Kaiserslautern, Kaiserslautern, Germany, Technical Report. 2012. Brugali D, Scandurra P. Component-based robotic engineering (part i)[tutorial][J]. IEEE Robotics &amp; Automation Magazine. 2009, 16(4): 84-96. Brugali D, Shakhimardanov A. Component-based robotic engineering (part ii)[J]. IEEE Robotics &amp; Automation Magazine. 2010, 17(1): 100-112.","tags":[{"name":"机器人软件设计","slug":"机器人软件设计","permalink":"https://ZhenshengLee.github.io/tags/机器人软件设计/"}]},{"title":"【整机】安装显卡驱动.md","date":"2016-09-03T16:48:57.000Z","path":"2016/09/04/160904-安装显卡驱动-md/","text":"前言 老板办公室来了台Linux主机，给自己的移动硬盘系统装下驱动，以后好好用 步骤禁用和卸载12345678910111213141516sudo subl /etc/modprobe.d/blacklist.conf(尾部添加)blacklist vga16fbblacklist nouveaublacklist rivafbblacklist nvidiafbblacklist rivatv(空行) 注意：code 对 sudo 的支持不好 1234sudo apt-get --purge remove nvidia-*sudo apt-get --purge remove xserver-xorg-video-nouveau-lts-vivid 重启电脑到命令行界面 关闭图形化界面 12345678sudo server lightdm stop* 运行驱动程序即可``` shellsudo sh ./Download/...run 重启服务 12sudo server lightdm start 重启电脑，完毕","tags":[{"name":"其他","slug":"其他","permalink":"https://ZhenshengLee.github.io/tags/其他/"}]},{"title":"【组件】ompl-open motion planning library1-基础理论","date":"2016-09-03T07:49:33.000Z","path":"2016/09/03/160903-ompl1/","text":"前言 open motion plan library，一个开源的运动规划库，主要以sample-based planning算法为主 包括两个核心组件，OMPL，算法库，和OMPL.app，前端用户界面 目录[TOC] 参考 ompl home page demos tutorials 作品展示 intergrated with your build systemPlanning algorithms.pdf 安装12sudo apt-get install libompl-dev ompl-demos 运行demo1234567891011121314151617181920212223242526272829303132cmake_minimum_required(VERSION 2.8.3)project(ompl_beginner)SET(CMAKE_CXX_FLAGS \"-std=c++11\")set(CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake)# find packagesfind_package(OMPL)# include dirsinclude_directories( $&#123;OMPL_INCLUDE_DIRS&#125; )add_executable(RigidBodyPlanning src/RigidBodyPlanning.cpp)target_link_libraries(RigidBodyPlanning $&#123;OMPL_LIBRARIES&#125; ) 基础知识绪论 ompl包括sample-based 运动规划器，以及构建新规划器的工具集合，用户还可以使用前段工具ompl.app。 熟练使用后，用户能够使用这个框架开发自己的规划算法功能，如sate sampling, collision, nearest neighbor searching. Sampling-based Motion Planning 机器人运动规划的目的在于：“从起点位姿到终点位姿，并且满足所有外部和内部约束”，当机器人拥有较多的自由度时，解算将变得很困难。 以经典的运动规划问题移动钢琴为例，在这个问题中，钢琴有六个自由度（x, y, z, roll, pitch, yaw），为了解算这个问题，我们必须计算出一个包含钢琴六个参数的数据集合，该数据集合被时间参数化，并且各个参数对于时间的改变应该是连续的。（从一个配置空间（starting configuration）移动到另一个配置空间（goal configuration），同时要满足避障的内，外部约束条件），这个问题已经被证明是一个PSPACE-hard 问题，解算非常困难。 规划理论的历史进程 精确的和近似的地图单元分解（graph-search）（代表：A*算法） 在某些例子中，可以将机器人的工作空间根据有无障碍分解成离散的栅格，这些分解可以建模为一个图(roadmap or graph)。根据这个图，问题变成：将一个点（机器人抽象而来）从一个栅格（包含起点）移动到另外一个栅格（包含终点）。这种规划的问题在于，当机器人拥有非线性动力学特性时（机器人不知道如何从一个栅格移动到另一个栅格，比如汽车，先锋机器人由于可以原地旋转，则不存在这个问题），路径规划是失败的。而且，更多的时候，状态空间是多维的，尤其是机器人运动内部有约束时，比如汽车（汽车有很多弯就拐不过去）。再次，状态空间分解空间复杂度非常大。 基于控制的方法（控制的典型特征是反馈环节feedback loop） 基于控制的方法尝试对系统进行建模，使用控制理论让系统沿着具体轨迹移动。这种方法在连续空间工作，并且拥有反馈环。基于控制的方法的优点是非常快速，可以在线规划。缺点是在复杂环境下不能够很好地计算期望的可行解。（关节空间规划，笛卡尔空间规划，直线插补，圆弧插补，样条曲线插补） 人工势场法 典型的人工势场法在工作空间的每个点计算一个函数，计算出的值作为这一点的斥力（或吸引力）。将机器人抽象为一个点，在势场图中沿梯度下降方向到目标点。优点是，可以考虑机器人上的多个点的动作，而且实时性好。缺点是，容易在梯度下降过程中陷入局部极小值。而且，理论上人工势场函数可以在任意维数的状态配置空间构造，这样就和解决原始问题一样了（Ideally the field would be constructed in the state space of the system, but this is equivalent to solving the original problem）。有一些简化方法使用了导航函数，保证人工势场拥有全局最小值。 随机/概率规划方法 这种方法被证明非常有用。在人工势场中添加布朗运动可以有效跳出局部极小区域。 另外，基于采样的规划方法，使用了随机化，采样和概率的方法，在高自由度系统或复杂动力学场景中非常有效。ompl即是这样的一种库，而且部署在ROS和moveIt!中。 基于采样的运动规划 基于采样的规划通过在机器人的状态空间中采样，来快速和有效的回应规划请求，特别是在复杂的约束和系统下尤其好用。传统方法往往空间和时间复杂度都非常大，在高维空间中往往没有什么用处。基于采样的方法在配置空间中搜索可行的状态点，并且继续通过采样连接这些状态点。这样可以产生足够灵活的可行解，并且是概率完全的，概率完全意味着，如果解存在，那么随着采样次数逐渐增大，可行解一定可以找到。不过，基于采样的方法无法确认一个问题不存在解。 一些定义 工作空间：机器人操作的物理空间，工作空间的边界被认为是障碍 状态空间：机器人的参数空间。参数空间包括所有的机器人在工作空间中的状态配置，状态空间中的一个点就是一个状态，注意状态空间可能是多维的 自由状态空间：状态空间的一个子集，在这个子集中的每个状态都是无障碍的 路径：状态空间中的连续状态点。如果路径中的每个点都是无障碍的，那么这个路径也是无障碍的。 所以，基于采样的规划方法的目标是：在状态空间中找到一个无障碍的路径。接下来介绍两种主要的基于采样的规划器。 概率地图（PRM） PRM是第一个基于采样的规划器，这种方法使用在状态空间中随机采样的方法构建roadmap，这种roadmap很像城市街区地图。 均匀采样，并连接起来，构造成roadmap，存储在图数据结构中。 需要注意的是：状态空间从来都不是显式定义的，所以必须要有障碍检测模块，每一次采样都要进行check，只有经过检查的才能够保留下来 有很多不同的采样的方法，改进采样策略往往很有用 一旦采样达到一定的数量，就开始构造边，标准RPM会对每一个采样点，搜索周围K临近点（在之前的采样点中找），使用局部规划器找到最短无障碍路径，局部规划器直接在这些采样点间进行插值（如直线差补），然后在这条直线中以一定的分辨率进行障碍检测，如果没有障碍点，那么这个边就作为合格边加入到roadmap中。 一旦roadmap构造完全，那么规划就成为连接起点和目标点的roadmap。 然后对这个roadmap进行图搜索，执行最短路径搜索 基于树的地图（RRT，快速随机树搜索） 现有的很多基于采样的规划器在自由状态空间中构造了树型结构，这种树形结构与上节讲的PRM很像，PRM的图带有环，这里的是树而已。由于基于树的规划器太多（RRT，EST，SBL，KPIECE），这里就不详细讲某一个，而是讲一讲大致的框架。 将机器人的起点当做一个树根，随机采样的点作为这个树的一个节点，树采用一种启发式扩张方法，这种启发式搜索条件往往就命名了这个方法，如果一个节点与树之间有无障碍路径，则将这个节点并入到树中。 尽管采样过程可能永远也不会采样到达机器人的目标状态，规划器往往都会设置有偏（bias）的扩张搜索，一旦将目标状态点并如到树中，路径规划就结束了。 PRM和RRT的不同 PRM需要构造覆盖全部状态空间的一个图，然后再连接起点和终点，而RRT不需要，只是逐渐的扩张树，直到终点。 所以，RRT特别适合于一次请求的规划，因为它构造的树并不包含其他目标点的信息，就算要求其到另外一个点，它也要重新进行树的扩张和生长。而PRM只需要构造一次即可。 Controls are usually directed commands, and require a specific pre-condition in order for a particular control to be valid. Tree-based methods, on the other hand, excel at planning with complex dynamics because of the directed, acyclic nature of the underlying data structure. Control information can be encoded for each edge of the tree, with the vertices of the tree satisfying the prerequisites for the valid controls.（没看懂） 总结 基于采样的规划方法所需内存更少 因为其不需要对状态空间进行显式表示 树和图等的数据结构保障了查找的效率和质量 基于采样的规划的基本组成 基于采样的规划特别适合在高维空间和复杂动力学环境下的路径规划，有很多中不同的规划器及其附件，但是核心是：在一次采样中，发生了什么？ 障碍检测 障碍检测非常有用。局部规划器在寻找无障碍路径时会用到（见PRM），在采样过程中也会用到。在复杂的高维系统中，显式表示状态空间会很难，但是规划器去不用去可以构造它，因为障碍检测执行了这一功能，如果没有障碍，则这个状态配置是合法的。 （这里“障碍”应该是广义的，不仅应该是物理障碍，还应该包括机器人在现有动力学约束下无法到达的状态区域） 最临近搜索 前面已经提到，规划算法需要找出离当前状态最近的一个状态，寻找无障碍路径。当需要判断机器人的两个状态的距离时就要用到这个方法。 但是，在高维空间中，欧式距离已经不能很好地计算。K-d树数据结构提供了一种方法。 OMPL OMPL核心算法库将这些都实现了！ 下期预告 使用ompl.app","tags":[{"name":"机器人软件设计","slug":"机器人软件设计","permalink":"https://ZhenshengLee.github.io/tags/机器人软件设计/"}]},{"title":"【ROS实战】机器人抓取仿真1-安装与构造","date":"2016-09-02T09:15:33.000Z","path":"2016/09/02/160902-机器人抓取仿真1/","text":"前言 机器人抓取操作仿真实战，使用nasa_r2机器人模型和gazebo7机器人仿真器 目录[TOC] 参考 catkin msg header generation issue nasa_ros_pkg 学习记录下载 下载nasa_r2_simulator-ingigo.zip, nasa_r2_common-hydro.zip, nasa_common_rosdep-master.zip, nasa_ros_pkg-deprecated_nasa_r2_common-xxx.zip 解压前三个文件夹 从nasa_ros_pkg-deprecated_nasa_r2_common-xxx.zip中复制nasa_r2_common_msgs到/masa_r2_common中 构建修改包nasa_r2_common_msgs构造描述文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240cmake_minimum_required(VERSION 2.8.3)project(nasa_r2_common_msgs)find_package(catkin REQUIRED COMPONENTS message_generation message_runtime std_msgs visualization_msgs geometry_msgs trajectory_msgs)## Generate messages in the 'msg' folderadd_message_files( FILES Gains.msg JointControl.msg JointStatusArray.msg JointStatus.msg PDMCStatus.msg PoseCommandArray.msg PoseCommand.msg PoseCommandParams.msg PoseCommandStatus.msg PoseTwistStamped.msg TorsoStatus.msg JointCommand.msg LabeledGripperPositionCommand.msg TorsoStatus.msg JointControlCalibrationMode.msg PDMCStatus.msg ForceControlAxisArray.msg ControllerJointSettings.msg ValueType.msg TrajectoryMonitorFactors.msg PoseTrajectoryReplan.msg Parameter.msg PoseCommandParams.msg PoseState.msg PoseTwistStamped.msg PriorityArray.msg LabeledTrajectoryMonitorFactors.msg LabeledGains.msg LabeledControllerJointSettings.msg VariantMapArray.msg JointTrajectoryReplan.msg JointControlData.msg JointControlMode.msg Gains.msg PowerState.msg VariantMap.msg JointControlClearFaultMode.msg JointCapability.msg PoseCommandStatus.msg SetParameterRequest.msg LabeledJointTrajectory.msg CommandStatus.msg JointStatusArray.msg ControllerPoseSettings.msg PoseCommandArray.msg JointControlDataArray.msg LabeledControllerPoseSettings.msg LabeledJointControlDataArray.msg SetParameterResponse.msg JointStatus.msg PoseCommand.msg SystemCore.msg SystemStatus.msg Modes.msg PoseTrajectoryPoint.msg JointControlCommandMode.msg JointControl.msg LabeledPoseTrajectory.msg WrenchMonitorLimit.msg JointControlCoeffState.msg WrenchState.msg PoseTrajectory.msg ForceControlAxis.msg LabeledJointState.msg StringArray.msg ReplanType.msg MappedType.msg)## Generate services in the 'srv' folderadd_service_files( FILES ParseTableScene.srv Power.srv ResetTableScene.srv Servo.srv SetJointMode.srv SetTipName.srv TakeSnapshot.srv SetTipName.srv Power.srv SetJointMode.srv TakeSnapshot.srv Servo.srv ResetTableScene.srv ParseTableScene.srv)## Generate added messages and services with any dependencies listed heregenerate_messages( DEPENDENCIES std_msgs geometry_msgs visualization_msgs trajectory_msgs)catkin_package( CATKIN_DEPENDS std_msgs geometry_msgs visualization_msgs message_generation message_runtime) 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\"?&gt;&lt;package&gt; &lt;name&gt;nasa_r2_common_msgs&lt;/name&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;description&gt;Messages for dealing with the Robonaut2/ISS Taskboard&lt;/description&gt; &lt;maintainer email=\"stephen.hart@nasa.gov\"&gt;Stephen Hart&lt;/maintainer&gt; &lt;maintainer email=\"davidvlu@gmail.com\"&gt;David V. Lu!!&lt;/maintainer&gt; &lt;license&gt;BSD&lt;/license&gt; &lt;url type=\"website\"&gt;http://ros.org/wiki/r2_msgs&lt;/url&gt; &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt; &lt;build_depend&gt;std_msgs&lt;/build_depend&gt; &lt;build_depend&gt;geometry_msgs&lt;/build_depend&gt; &lt;build_depend&gt;visualization_msgs&lt;/build_depend&gt; &lt;build_depend&gt;message_runtime&lt;/build_depend&gt; &lt;build_depend&gt;message_generation&lt;/build_depend&gt; &lt;run_depend&gt;std_msgs&lt;/run_depend&gt; &lt;run_depend&gt;visualization_msgs&lt;/run_depend&gt; &lt;run_depend&gt;geometry_msgs&lt;/run_depend&gt; &lt;run_depend&gt;message_runtime&lt;/run_depend&gt; &lt;run_depend&gt;message_generation&lt;/run_depend&gt;&lt;/package&gt; 修改 gazebo_taskboard 构造描述文件123456789cmake_minimum_required(VERSION 2.8.3)project(gazebo_taskboard)add_definitions(-std=c++11)# xxxxxxxadd_dependencies(gazebo_taskboard gazebo_taskboard_generate_messages_cpp) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=\"1.0\"?&gt;&lt;package&gt; &lt;name&gt;gazebo_taskboard&lt;/name&gt; &lt;version&gt;0.5.3&lt;/version&gt; &lt;description&gt;The gazebo_taskboard package&lt;/description&gt; &lt;maintainer email=\"stephen.hart@nasa.gov\"&gt;Stephen Hart&lt;/maintainer&gt; &lt;maintainer email=\"davidvlu@gmail.com\"&gt;David Lu!!&lt;/maintainer&gt; &lt;!-- One license tag required, multiple allowed, one license per tag --&gt; &lt;!-- Commonly used license strings: --&gt; &lt;!-- BSD, MIT, Boost Software License, GPLv2, GPLv3, LGPLv2.1, LGPLv3 --&gt; &lt;license&gt;TODO&lt;/license&gt; &lt;url type=\"website\"&gt;http://wiki.ros.org/gazebo_taskboard&lt;/url&gt; &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt; &lt;build_depend&gt;roscpp&lt;/build_depend&gt; &lt;build_depend&gt;rospy&lt;/build_depend&gt; &lt;build_depend&gt;std_msgs&lt;/build_depend&gt; &lt;build_depend&gt;gazebo&lt;/build_depend&gt; &lt;build_depend&gt;message_generation&lt;/build_depend&gt; &lt;run_depend&gt;message_runtime&lt;/run_depend&gt; &lt;run_depend&gt;std_msgs&lt;/run_depend&gt; &lt;run_depend&gt;pluginlib&lt;/run_depend&gt; &lt;run_depend&gt;actionlib&lt;/run_depend&gt; &lt;run_depend&gt;geometry_msgs&lt;/run_depend&gt; &lt;run_depend&gt;rostest&lt;/run_depend&gt; &lt;run_depend&gt;message_generation&lt;/run_depend&gt; &lt;export&gt; &lt;gazebo plugin_path=\"$&#123;prefix&#125;/lib\" /&gt; &lt;/export&gt;&lt;/package&gt; 修改gazebo_gripper, gazebo_interface构造描述文件12add_definitions(-std=c++11) catkin_make 应该不会出错 roslaunch 请结合gazebo操作帮助文档，使用r2_gazebo中的launch文件 下期预告 【ROS实战】机器人抓取仿真2-模型与控制","tags":[{"name":"机器人软件设计","slug":"机器人软件设计","permalink":"https://ZhenshengLee.github.io/tags/机器人软件设计/"}]},{"title":"卷首语","date":"2016-09-01T16:29:20.000Z","path":"2016/09/02/160901-卷首语/","text":"亲爱的朋友： 你好！ 欢迎访问我的技术博客！ 本博客于2016年8月开始载文，主要目的是为企业招聘主管展现本人的学习轨迹与职业能力。本博客所载文章全部是我研究生期间在实验室学习生活做的笔记，原本是存储在ONENOTE和WizNote软件上，以时间为线索记录的“流水账”，现突发奇想，本着对技术的热爱，建立一个自己的博客。这样做一方面可以全面梳理自己所学知识和业务能力，提升自己对技术的理解和写作能力；另一方面，也能够为企业HR考察自己提供一些便利。然而在学习工作之余做梳理工作本是一件漫长的过程，本博客将首先将笔记本内容上传，再逐渐地（在相当长的时间）将笔记整理为一篇一篇博文，如果博客内容影响到你的知识获取，本人表示歉意。 本人的笔记内容具有以下特点： 以时间为线索记流水账，学到哪儿记到哪儿。笔记嘛，就是这样，一个窗口工作，鼠标一移，另一个窗口记笔记，还经常会将网页内容发送至笔记中； 包含很多简单，甚至“不足挂齿”的基础知识。一方面本人还是学生，在整个行业中实为一位无名之辈，另一方面，因为自己本科学的不是计算机专业，所以有很多外围知识到现在依然并未深刻理解，本人也一直在努力学习计算机本科的几门专业基础课； 主要的“干货”是自己的工作思路和对技术的理解。这儿并没有非常详细的操作步骤，一般会给你一个网址，也不会整段整段地翻译帮助文档，而是会直接贴英文原版内容。在我的笔记当中，有很多自己的所思所想，可能很杂乱无章，但我认为很有用，因为这样的思维才是解决问题的基础。 本博客还会转载一些生活上的小品文，都是我认为应该多读多想的，欢迎读者能够留下评论，分享自己的见解。 简单介绍一下自己：本科机械设计制造及自动化，方向为机械设计，毕业课题工作为机构设计，运动仿真及有限元分析；研究生专业为机械电子工程，方向为智能机器人，毕业课题工作为机器人协作控制系统软件开发。 相关栏目正在建设中，敬请期待！ 最后，希望我的博客能够帮助到你：） 再次感谢！ 预祝商祺 附：博客写作方式及版权声明 如前所说，本博客所有文章均来自个人笔记本，会经常引用别人的网页（文章），但会全部给出出处，如果侵犯了他人权利，但请在博客评论指出，本人会删除。 博客文章全部用Markdown编辑器编辑好发布，由于第一次接触，如有不便，敬请谅解。 本博客欢迎转载。","tags":[{"name":"写在前面","slug":"写在前面","permalink":"https://ZhenshengLee.github.io/tags/写在前面/"}]},{"title":"【编辑】vscode C++程序设计","date":"2016-09-01T06:43:28.000Z","path":"2016/09/01/160901-vscodeC-程序设计/","text":"前言 此处介绍使用vscode进行cpp程序设计，使用make进行构建，gdb进行调试 此次项目用于到PAT刷题 以后逐步地使用gTest 进行测试，valgrind 进行深度检查，log4cplus进行日志输出 目录[TOC] 参考 how-do-i-set-up-vscode-to-compile-c-code vscode c++ programming vscode external tasks gdb does’t find sources 学习记录安装c/c++插件1234Ctrl+Shift+Pext install cpp 文件准备12345678910111213141516cd pat-basicmkdir binmkdir includemkdir srctouch Makefilecd ./srctouch hello_world.cpptouch 1035.cpp 编写Makefile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748PROJECT := zs_pat_basic# define files and directoriesCXX_SRCS := $(shell find src/ -name \"*.cpp\")HEADER_FILES := $(shell find include/ -name \"*.h\")SRC_DIR := ./srcINCLUDE_DIR := ./includeBUILD_DIR := ./bin# define debug optionsDEBUG_OPTIONS := -g# define build targets.PHONY : allall: $(BUILD_DIR)/hello_world \\ $(BUILD_DIR)/1035 \\ $(BUILD_DIR)/1050 \\$(BUILD_DIR)/% : $(SRC_DIR)/%.cpp $(CXX) -o $@ $(DEBUG_OPTIONS) -I$(INCLUDE_DIR) $&lt;.PHONY : clean clean : rm -rf $(BUILD_DIR)/* 编写c++配置文件c_cpp_properties.json vscode自身配置文件全部在./.vscode/目录下，在vscode资源浏览器中可以看到 注意，刚刚对cpp文件进行编辑后，#include 这句话是有红色下划线警示的，提示找不到文件，这时使用鼠标悬浮功能，点击“红色灯泡”，vscode会自动在配置文件夹中新建c_cpp_properties.json文件，文件内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&#123; \"configurations\": [ &#123; \"name\": \"Mac\", \"includePath\": [\"/usr/include\"], \"browse\" : &#123; \"limitSymbolsToIncludedHeaders\" : true, \"databaseFilename\" : \"\" &#125; &#125;, &#123; \"name\": \"Linux\", \"includePath\": [\"/usr/include\"], \"browse\" : &#123; \"limitSymbolsToIncludedHeaders\" : true, \"databaseFilename\" : \"\" &#125; &#125;, &#123; \"name\": \"Win32\", \"includePath\": [\"c:/Program Files (x86)/Microsoft Visual Studio 14.0/VC/include\"], \"browse\" : &#123; \"limitSymbolsToIncludedHeaders\" : true, \"databaseFilename\" : \"\" &#125; &#125; ], \"clang_format\" : &#123; \"style\" : \"file\", \"fallback-style\" : \"LLVM\", \"sort-includes\" : false &#125;&#125; 配置make任务 vscode没有内置make功能，需要借助Task功能进行配置 Ctrl+shift+P 进入命令模式，键入tasks: Configure Task Runner，此时vscode自动生成task.json文件，编写内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"0.1.0\", \"command\": \"make\", \"isShellCommand\": true, \"tasks\": [ &#123; \"taskName\": \"Makefile\", // Make this the default build command. \"isBuildCommand\": true, // Show the output window only if unrecognized errors occur. \"showOutput\": \"always\", // No args \"args\": [\"all\"], // Use the standard less compilation problem matcher. // zs: The problem matcher is for gcc task, not for make. \"problemMatcher\": &#123; \"owner\": \"cpp\", \"fileLocation\": [\"relative\", \"$&#123;workspaceRoot&#125;\"], \"pattern\": &#123; \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", \"file\": 1, \"line\": 2, \"column\": 3, \"severity\": 4, \"message\": 5 &#125; &#125; &#125; ]&#125; 编写调试配置文件launch.json 同样，vscode也需要自己定义调试相关选项 点击左侧工具栏”Debug“，点击”齿轮“按钮，此时vscode自动生成launch.json文件，编写内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&#123; \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"C++ Launch\", \"type\": \"cppdbg\", \"request\": \"launch\", \"targetArchitecture\": \"x64\", \"program\": \"$&#123;workspaceRoot&#125;/bin/hello_world\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"$&#123;workspaceRoot&#125;\", \"environment\": [], \"externalConsole\": true, \"linux\": &#123; \"MIMode\": \"gdb\" &#125;, \"osx\": &#123; \"MIMode\": \"lldb\" &#125;, \"windows\": &#123; \"MIMode\": \"gdb\" &#125; &#125;, &#123; \"name\": \"C++ Attach\", \"type\": \"cppdbg\", \"request\": \"launch\", \"targetArchitecture\": \"x64\", \"program\": \"$&#123;workspaceRoot&#125;/bin/hello_world\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"$&#123;workspaceRoot&#125;\", \"environment\": [], \"processId\": \"$&#123;command.pickProcess&#125;\", \"externalConsole\": false, \"linux\": &#123; \"MIMode\": \"gdb\" &#125;, \"osx\": &#123; \"MIMode\": \"lldb\" &#125;, \"windows\": &#123; \"MIMode\": \"gdb\" &#125; &#125; ]&#125; 使用流程 编写hello_world.cpp文件 设置断点 Ctrl+shift+B进行make 点击左侧工具栏”调试“按钮进入调试工具区，点击绿色开始运行按钮，即可开始调试","tags":[{"name":"机器人系统开发","slug":"机器人系统开发","permalink":"https://ZhenshengLee.github.io/tags/机器人系统开发/"}]},{"title":"【编辑】vi command","date":"2016-08-16T08:49:48.000Z","path":"2016/08/16/160816-vi-command/","text":"[TOC] 《嵌入式Linux开发基础知识》 前言 远程访问需要用到shell内置文本编辑器，必须要学的基础技能 以HELLOWORLD程序为例子进行最基本的程序编辑，编译，调试练习！ VI学习 有三种状态：编辑方式，插入方式和命令方式，当你进入vi时，会首先进入命令方式（同时也是编辑方式），按下i进入插入方式，按下ESC回到命令状态（也是编辑方式） 在插入方式下，不能打入指令，必需先按〈Esc〉键，返回命令方式。假若户不知身处何态，也可以按〈Esc〉键，不管处於何态，都会返回命令方式。在修改文件时，如何存档及退出指定文件都非常重要。在 vi 内，行使存档或退出的指令时，要先按冒号（: ） ，改变为命令方式，用户就可以看见在荧幕左下方，出现冒号（: ） ，显示 vi 已经改为指令态，可以进行存档或退出等工作。 常用命令命令模式（ESC进入）查看 放弃存档退出 1:q! 只读文件强行存档 1:w! 存档并退出 1:x 跳转到n行 12nG 显示当前行列数 1Ctrl+G 左上下右 1234hjkl 进入编辑模式 光标前，后，所处位置插入字符 1i a r i=insert; a=append; r=replace; 一行开始处插入 1I 行尾处插入 1A 光标下新开一行 1o 光标上方新开一行 1O 编辑模式 清除整行开始填充 1cc 删除当前字符 1x 删除光标后n个字符 1nx 删除光标前n个字符 1nX 删除光标后n个单词 1ndw 删除整行 1dd 删除光标到行末 1D 回退 1u 搜索 往后搜索str直到文件开头 1?str &lt;return&gt; 重复检索 12nN 复制与粘贴 打开两个文件 1vi file1 file2 拷贝所在行 1yy 切换到下一个文件 1:n 当前光标处粘贴 1p 切换回文件 1:n 另存为 行数之间另存为文件 1:20,59w /tmp/1 转到shell执行1:!s","tags":[{"name":"机器人系统开发","slug":"机器人系统开发","permalink":"https://ZhenshengLee.github.io/tags/机器人系统开发/"}]},{"title":"【编译】catkin build system","date":"2016-08-16T08:47:24.000Z","path":"2016/08/16/160816-catkin-build-system/","text":"[TOC] 前言 是基于CMake，使用一系列CMake 宏制作而成的ROS构造系统 参考 Catkin Documentation ROS Wiki **推荐一本书：《深入理解软件构建系统》 CMakeLists综述 此文件是CMake 构造系统的输入文件，构造描述文件记录了代码如何构建以及如何安装，catkin 构建系统基于CMakeLists，但是也添加了额外的不多的约束 总体结构（严格按照顺序） Required CMake Version (cmake_minimum_required) Package Name (project()) Find other CMake/Catkin packages needed for build (find_package()) Message/Service/Action Generators(add_message_files(), add_service_files(), add_action_files()) Invoke message/service/action generation (generate_messages()) Specify package build info export (catkin_package()) Libraries/Executables to build (add_library()/add_executable()/target_link_libraries()) Tests to build (catkin_add_gtest()) Install rules (install()) find_package()思想 CMake中的find模块的作用在于自动寻找已经存在的软件组件，这里的组件概念对应于ROS中的包的概念。如 1find_package(catkin REQUIRED COMPONENTS nodelet) 意思是，寻找catkin库中的nodelet组件*，在这个语句中不能添加运行时依赖* 问题来了，为什么Catkin是一个大库，ROS包是一个组件呢？其实官方文档说了，你可以可以这么写 1find_package(catkin REQUIRED);find_package(nodelet REQUIRED) ，因为使用catkin编译，必须包含catkin包，然后你再包含nodelet包，但是这样也太不方便了。所以原因就是要方便，当然也不是方便这么一点点，还有关于环境变量。 Catkin packages are not really components of catkin. Rather the components feature of CMake was utilized in the design of catkin to save you significant typing time. For catkin packages, if you findpackage them as components of catkin, this is advantageous as a single set of environment variables is created with the catkin prefix. 注意：boost不是catkin组件哦 catkin_package()思想 是一个CMake 宏，用来明确catkin构建系统信息，这些信息用来生成pkg-config和CMake文件 This function must be called before declaring any targets with add_library() or add_executable(). The function has 5 optional arguments: 12345678910INCLUDE_DIRS - The exported include paths (i.e. cflags) for the packageLIBRARIES - The exported libraries from the projectCATKIN_DEPENDS - Other catkin projects that this project depends onDEPENDS - Non-catkin CMake projects that this project depends onCFG_EXTRAS - Additional configuration options 关于标的的构建选项 自定义输出目录。 12set_target_properties(python_module_library PROPERTIES LIBRARY_OUTPUT_DIRECTORY $&#123;CATKIN_DEVEL_PREFIX&#125;/$&#123;CATKIN_PACKAGE_PYTHON_DESTINATION&#125;) 包含目录和库，创建可执行文件和库文件 完全是CMake知识 消息，服务和动作 一句话，先add_service_files()，再generate_messgaes()，可谓是一键创造消息服务动作 Messages (.msg), services (.srv), and actions (.action) files in ROS require a special preprocessor build step before being built and used by ROS packages. The point of these macros is to generate programming language-specific files so that one can utilize messages, services, and actions in their programming language of choice. The build system will generate bindings using all available generators (e.g. gencpp, genpy, genlisp, etc). 一系列注意事项（懒得翻译了） These macros must come BEFORE the catkin_package() macro in order for generation to work correctly. Your catkin_package() macro must have a CATKIN_DEPENDS dependency on message_runtime. You must use find_package() for the package message_generation, either alone or as a component of catkin Your package.xml file must contain a build dependency on message_generation and a runtime dependency on message_runtime. This is not necessary if the dependencies are pulled in transitively from other packages. If you have a package which builds messages and/or services as well as executables that use them, you need to create an explicit dependency on the automatically-generated message target so that they are built in the correct order. (some_target is the name of the target set by add_executable()): 单元测试1catkin_add_gtest(myUnitTest test/utest.cpp) 安装（略）Package.xml使用XML语言设置依赖（略） 实际上就是使用标记语言说明本包的基本情况 设置本包为Metapackages 1234&lt;export&gt; &lt;metapackage /&gt; &lt;/export&gt; 12345cmake_minimum_required(VERSION 2.8.3)project(&lt;PACKAGE_NAME&gt;)find_package(catkin REQUIRED)catkin_metapackage() 专题：消息，服务，重配置的构造描述文件 只有一个包或节点是消息，服务，动作的提供者时，在构造描述文件中才需要添加相应的描述语句，如果是接受者，那么不需要提供。 请比较rosaria和rosaria_client构造描述文件的区别 当需要使用到新的消息和服务类型时，才需要再构造描述文件中添加add语句 通过包含其他含有std_msgs的包，如rosaria，也可以间接包含std_msgs 嘛的，官方例程建立消息和服务都还要 1add_dependencies() 但是rosaria中没有这么多废话 消息和服务的构造描述文件 123456789101112find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation)catkin_package( ... CATKIN_DEPENDS message_runtime ... ...)generate_messages(# DEPENDENCIES# std_msgs) 123&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;run_depend&gt;message_runtime&lt;/run_depend&gt; 为什么有 1add_msgs() 1add_srvs() 而只有 1generate_messages() 没有 1generate_srvs() 等？因为服务和参数重配置本质上都是基于msg消息机制，多说一句，消息机制是建立在XMLRPC远程过程调用机制上的，进而建立在TCP/IP网络协议上 《UNIX网络编程：进程间通信》重配置的构造描述文件 实例：解决zsDoor模块缺失问题查看stereo_wall_detection的CMakeLists.txt","tags":[{"name":"机器人软件构造","slug":"机器人软件构造","permalink":"https://ZhenshengLee.github.io/tags/机器人软件构造/"}]},{"title":"【测试】gtest and rostest","date":"2016-08-16T08:44:05.000Z","path":"2016/08/16/160816-gtest-and-rostest/","text":"[TOC] 前言为什么要学GTest 开源框架，完全免费 用得人多，项目多，比如ROS就用这个做测试，这是我学习GTEST的直接原因 软件工程师入门啊！ 致谢 Linux 大棚 ROSTest 好的测试框架应该是（软件测试思想） 软件应该是独立的且可重复的，每个测试应该是一个独立的对象 应该有一套好的方法来组织测试，这种组织方法能够较好的反映程序代码的结构 测试应该是可迁移的且可复用的（平台中立）（支持多种编译器） 在测试失败时，要能够提供足够充分的测试信息 测试框架应该让开发者从琐碎的工作中解脱出来，让他们能够专注在测试内容上 测试应该是高效的 科普 如果你是一名开发工程师，或者你编写的程序要用到生产环境中，那么，你不可避免的需要学习和掌握一种自动化测试框架，以确保你的程序测试充分，质量上乘。 其实啊，测试工具是什么并不重要，重要的是测试思想，还是在大学期间上过的课，亲身做过的项目才是真货，好吧，去考个计算机三级软件测试技术？ GTest 入门综述 第一步就是：把gtest编译成一个库，并且链接到你的测试程序中 你的测试项目程序要引用gtest/gtest.h，你的gtest安装在GTEST_ROOT路径下 断言assertion gtest 中的断言是一些宏，assertion在测试一个函数时，可以有两种方案，即ASSERT*和EXPECT。在失败发生时，ASSERT_这类assertion会产生fatal failure，并且会终止当前函数；而EXPECT_*则只会产生nonfatal failure。 常用的宏有 EXPECT_EQ/NE/LT/LE/GT/GE([表达式],[表达式]) 对于ASSERT_EQ比较两个C字符串指针，只会检查两个指针是否指向同一块区域，要想检查两个（C风格字符串）字符串内容是否相同，要使用ASSERT_STREQ，不过比较两个C++字符串的话就用ASSERT_EQ就可以了。 特殊的比较宏——字符串比较宏 ASSERT_STRCASEEQ()，此处CASE指不区分大小写的比较 字符串比较宏的特殊规则 NULL和空字符串””是不相等的。 如果你想了解更多有关字符串比较的trick方法，比如在assertion中处理子字符串、前缀、后缀、正则匹配等，请进入“高级gtest指南”。 创建一个test 三件事 使用TEST()宏来定义和命名一个test函数，这个test函数不需要return任何值。 在这个test函数中，你可以写任何C++语句，并且使用assertion来检查。 这个test的结果是由assertion决定的。如果任何一个assertion失败了，或者这个test函数崩溃了，这个test则会返回fail。否则，会返回success。 语法 1234567TEST(test_case_name, test_name) &#123;... test body ...&#125; Test Fixtures 如果你发现你所写的多个test都在操作类似的数据，那么我推荐你使用test fixture。这个特性允许你在不同的test里复用相同的配置。 机制主要是类的继承，具体请看参考教程，见文首 使用Test Fixtures时的宏 123456TEST_F(test_case_name, test_name) &#123;... test body ...&#125;// test_case_name 必须是定义的test fixture类的名称 运行测试如果要触发运行，请执行RUN_ALL_TESTS()宏，如果所有的test都测试通过，它会返回0，否则会返回1。 注意 你bixu在你的main函数中return这个值。 编写测试的main函数 参考如下模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include \"this/package/foo.h\"#include \"gtest/gtest.h\"namespace &#123;// The fixture for testing class Foo.class FooTest : public ::testing::Test &#123;protected:// You can remove any or all of the following functions if its body is empty.FooTest() &#123;// You can do set-up work for each test here.&#125;Virtual ~FooTest() &#123;// You can do clean-up work that doesn't throw exceptions here.&#125;// If the constructor and destructor are not enough for setting up// and cleaning up each test, you can define the following methods:virtual void SetUp() &#123;// Code here will be called immediately after the constructor&#125;virtual void TearDown() &#123;// Code here will be called immediately after each test&#125;// Object declared here can be used by all tests in the test case for Foo.&#125;;// Tests that the Foo::Bar() method does Abc.TEST_F(FooTest, MethodBarDoesAbc) &#123;const string input_filepath = \"this/package/testdata/myinputfile.dat\";const string output_filepath = \"this/package/testdata/myoutputfile.dat\";Foo f;EXPECT_EQ(0, f.Bar(input_filepath, output_filepath));&#125;// Tests that Foo does Xyz.TEST_F(FooTest, DoesXyz) &#123;// Execises the Xyz feature of Foo.&#125;&#125; // namespaceint main(int argc, char* argv[]) &#123;::testing::InitGoogleTest(&amp;amp;argc, argv);return RUN_ALL_TESTS();&#125; ROSTest 学习 rostest是roslaunch的扩展，允许跨越多节点进行测试！文件格式可以是.test或.launch，非常建议将测试launch文件嵌入到普通launch文件中 编写测试前期概念 两种层次上的测试：一种是节点层级的测试，主要测试节点与节点之间的交互是否有效，如消息订阅，服务请求等；另一种是代码层级的测试，主要测试节点内部具体执行的程序的有效性，如特定算法。 实际上需要编写一些测试节点来运行测试，rostest基于gtest框架 编写 Writing C++ tests with gtest 构造描述文件 CMakeLists 1234567if(CATKIN_ENABLE_TESTING) find_package(rostest REQUIRED) add_rostest_gtest(tests_mynode test/mynode.test src/test/test_mynode.cpp [more cpp files]) target_link_libraries(tests_mynode $&#123;catkin_LIBRARIES&#125;)endif() Package.xml 12 launch file 123456&lt;launch&gt; &lt;node pkg=\"mypkg\" type=\"mynode\" name=\"mynode\" /&gt; &lt;test test-name=\"test_mynode\" pkg=\"mypkg\" type=\"test_mynode\" /&gt;&lt;/launch&gt; launch 文件会启动节点后立即启动测试节点 运行项目：测试zsDoor项目","tags":[{"name":"机器人软件构造","slug":"机器人软件构造","permalink":"https://ZhenshengLee.github.io/tags/机器人软件构造/"}]},{"title":"【调试】gdb, ros and roslaunch","date":"2016-08-16T08:42:12.000Z","path":"2016/08/16/160816-gdb-ros-and-roslaunch/","text":"[TOC] 前言 这是必须学习的技能，但是不需要精通，应该利用更高层的工具 在ROS项目开发过程中应用，在使用roslaunch过程中应用gdb 在CLion，VSCode使用过程中应用调试功能 参考 《ROS机器人程序开发》 《嵌入式Linux开发基础知识》 roslaunch wiki gdb学习 是一个用来调试C/C++程序的强力调试器，常用功能有：监视程序中变量的值；设置断点；单步执行 为了使gdb正常工作，你必须使你的程序在编译时包含调试信息。-g```调试信息包括你程序里的每一个变量的类型和在可执行文件里的地址映射以及源代码的行号。12* 你可以使用gdb调试一个可执行文件，也可以用gdb检查一个因程序异常终止而产生的core文件，或者与一个正在运行的程序相连。更多请参考```gdb -h 命令支持tab补齐特性 使用要点1234567891011121314151617gdb #打开调试器file FILE #装载指定可执行文件break NUM #在指定的行上设置断点bt #显示所有的调用栈帧，显示函数的调用顺序clear FILENAME:NUM #删除特定源文件行上的断点next #在不单步执行进入其他函数的情况下，向前执行一行源代码continue #继续执行display EXPR #每次程序停止后显示表达式的值，表达式由程序定义的变量组成print EXPR #显示表达式的值info files #显示被调试文件的详细信息info func #显示所有函数名称info local #显示当函数中的局部变量信息info prog #显示被调试程序的执行状态info var #显示所有的全局和静态变量名称kill #终止正在被调试的程序list #显示源代码段make #在不退出gdb的情况下运行make工具 ROS node debug with gdb（使用gdb调试ROS节点） 从调试任意C/C++可执行文件的标准方法开始 123456roscoregdb bin/exampler ros节点启动时调用gdb调试器 需要在launch文件中添加 1launch-prefix=&quot;xterm-egdb--args&quot; 该语句意思是：加载节点并等待运行。注意，因为是在xterm中创建gdb绘画，所以还有一个调试窗口。 launch-prefix其实是一个前置启动工具，我们同样可以使用launch-prefix=&quot;valgrind&quot;来在启动节点之前启动valgrind工具检测内存泄露，并执行性能分析。valgrind.org 更多请见 How to Roslaunch Nodes in Valgrind or GDB roslaunch 学习和调试 launch文件：功能包名传递给pkg属性，节点名传递给type属性，由于同一个节点可以运行多个实例，因此需要给每个实例一个节点名以作区分，即name属性，最好将这些属性配置输出到屏幕，这样就会在启动节点的shell窗口中输出相应调试信息，output=screen。 实例：调试ROS项目","tags":[{"name":"机器人软件构造","slug":"机器人软件构造","permalink":"https://ZhenshengLee.github.io/tags/机器人软件构造/"}]},{"title":"【部署】Git拉取远程分支","date":"2016-08-16T08:38:48.000Z","path":"2016/08/16/160816-Git拉取远程分支/","text":"[TOC] 前言 自己是git新手，在本地没有分支的时候不知道怎么拉取（从别的电脑push的）远程分支，完全没办法，只好删除整个文件夹重新clone，后来到网上好好学了学，总算知道了。 这里重点介绍一下本地没有该分支，需要到远程拉取该分支的方法 致谢xqs83 错误做法123456git branch link-rosforlvgit checkout link-rosforlvgit pull origin link-rosforlv 因为，这样建立的branch是以master为基础建立的，再pull下来的话，会和master的内容进行合并，有可能会发生冲突 正确用法 用 1git branch -a 查看包括远程分支在内的所有分支： 使用 1checkout 命令来把远程分支取到本地，并自动建立tracking 12git checkout -b link-rosforlv origin/link-rosforlv 或者使用-t参数，它默认会在本地建立一个和远程分支名字一样的分支 12git checkout -t origin/link-rosforlv 也可以使用fetch来做： git fetch origin link-rosforlv:link-rosforlv 不过通过fetch命令来建立的本地分支不是一个track branch，而且成功后不会自动切换到该分支上 结语 学完之后才发现有这么多种方法可以做到这些，瞬觉自己才疏学浅，惭愧惭愧。","tags":[{"name":"机器人软件构造","slug":"机器人软件构造","permalink":"https://ZhenshengLee.github.io/tags/机器人软件构造/"}]},{"title":"【ROS】标记工具-Marker","date":"2016-08-16T08:34:55.000Z","path":"2016/08/16/160816可视化工具-Marker/","text":"前言 顾名思义，标记工具就是在数据可视化的基础上加上用户自定义标记，用来强调某种特征或者添加用户自己想加上的东西 visualization stack 现在已经包含到RViz中，但是我们主要还是要学习这个包集中的东西 [TOC] 参考 visualization_msgs Tutorials RViz Turorials RViz User Guid visuallization_msgs/markersSending Basic Shapes to RViz基本原理 注册一个visualization::marker消息，定义好，然后发出去，RViz在收到后在指定位置显示特定形状 关键代码 package.xml 12catkin_create_pkg using_markers roscpp visualization_msgs CMakeList.txt 123add_executable(basic_shapes src/basic_shapes.cpp)target_link_libraries(basic_shapes $&#123;catkin_LIBRARIES&#125;) .cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;visualization_msgs/Marker.h&gt;ros::Publisher marker_pub = n.advertise&lt;visualization_msgs::Marker&gt;(\"visualization_marker\", 1);uint32_t shape = visualization_msgs::Marker::CUBE; visualization_msgs::Marker marker;// Set the frame ID and timestamp. See the TF tutorials for information on these.marker.header.frame_id = \"/my_frame\";marker.header.stamp = ros::Time::now();// Set the namespace and id for this marker. This serves to create a unique ID// Any marker sent with the same namespace and id will overwrite the old onemarker.ns = \"basic_shapes\";marker.id = 0;// Set the marker type. Initially this is CUBE, and cycles between that and SPHERE, ARROW, and CYLINDERmarker.type = shape;// Set the marker action. Options are ADD, DELETE, and new in ROS Indigo: 3 (DELETEALL)marker.action = visualization_msgs::Marker::ADD;// Set the pose of the marker. This is a full 6DOF pose relative to the frame/time specified in the headermarker.pose.position.x = 0;marker.pose.position.y = 0;marker.pose.position.z = 0;marker.pose.orientation.x = 0.0;marker.pose.orientation.y = 0.0;marker.pose.orientation.z = 0.0;marker.pose.orientation.w = 1.0;// Set the scale of the marker -- 1x1x1 here means 1m on a sidemarker.scale.x = 1.0;marker.scale.y = 1.0;marker.scale.z = 1.0;// Set the color -- be sure to set alpha to something non-zero!marker.color.r = 0.0f;marker.color.g = 1.0f;marker.color.b = 0.0f;marker.color.a = 1.0;marker.lifetime = ros::Duration();// Publish the markerwhile (marker_pub.getNumSubscribers() &lt; 1)&#123; if (!ros::ok()) &#123; return 0; &#125; ROS_WARN_ONCE(\"Please create a subscriber to the marker\"); sleep(1);&#125;marker_pub.publish(marker); Sending Points and lines 本质同发送基本形状，都是定义一个消息，然后发送即可，只是点和线可能是数组数据结构，定义起来麻烦一点 Interactive Marker基本原理 不仅是将特定形状显示在RViz中，而且用户可以使用鼠标和上下文菜单进行交互，从而实现更复杂的任务 依然是由消息类型来定义，visualization_msgs/InteractiveMarker，这个消息包含一个上下文菜单，多个控件（visualization_msgs/InteractiveMarkerControl消息类型表示）。这些控件用来定义交互式标记的各个部分，每一部分都有不同功能。 要使用交互式标记，需要在节点中实例化一个InteractiveMarkerServer对象，作为与RViz联系的代理服务器，RViz作为客户端向节点发送不同的消息通知，以此来产生交互。 相关的消息类型有 visualization_msgs/InteractiveMarker visualization_msgs/InteractiveMarkerControl visualization_msgs/InteractiveMarkerFeedback 此外还有MenuHandler 帮助文档 Simple Interactive Marker Server 关键思想 InteractiveMarker–&gt;control–&gt;Marker，标记包含控件，类间是组合关系，均是一对多。 咦？为什么同时有将control赋给marker的属性和将marker赋给control的属性？原来如此 Server给RViz发送Update消息，RViz给Server发送Feedback，Server处定义对Feedback的响应函数 关键代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;ros/ros.h&gt;#include &lt;interactive_markers/interactive_marker_server.h&gt;void processFeedback( const visualization_msgs::InteractiveMarkerFeedbackConstPtr &amp;feedback )&#123; ROS_INFO_STREAM( feedback-&gt;marker_name &lt;&lt; \" is now at \" &lt;&lt; feedback-&gt;pose.position.x &lt;&lt; \", \" &lt;&lt; feedback-&gt;pose.position.y &lt;&lt; \", \" &lt;&lt; feedback-&gt;pose.position.z );&#125;int main(int argc, char** argv)&#123; ros::init(argc, argv, \"simple_marker\"); // create an interactive marker server on the topic namespace simple_marker interactive_markers::InteractiveMarkerServer server(\"simple_marker\"); // create an interactive marker for our server visualization_msgs::InteractiveMarker int_marker; int_marker.header.frame_id = \"base_link\"; int_marker.header.stamp=ros::Time::now(); int_marker.name = \"my_marker\"; int_marker.description = \"Simple 1-DOF Control\"; // create a grey box marker visualization_msgs::Marker box_marker; box_marker.type = visualization_msgs::Marker::CUBE; box_marker.scale.x = 0.45; box_marker.scale.y = 0.45; box_marker.scale.z = 0.45; box_marker.color.r = 0.5; box_marker.color.g = 0.5; box_marker.color.b = 0.5; box_marker.color.a = 1.0; // create a non-interactive control which contains the box visualization_msgs::InteractiveMarkerControl box_control; box_control.always_visible = true; box_control.markers.push_back( box_marker ); // add the control to the interactive marker int_marker.controls.push_back( box_control ); // create a control which will move the box // this control does not contain any markers, // which will cause RViz to insert two arrows visualization_msgs::InteractiveMarkerControl rotate_control; rotate_control.name = \"move_x\"; rotate_control.interaction_mode = visualization_msgs::InteractiveMarkerControl::MOVE_AXIS; // add the control to the interactive marker int_marker.controls.push_back(rotate_control); // add the interactive marker to our collection &amp; // tell the server to call processFeedback() when feedback arrives for it server.insert(int_marker, &amp;processFeedback); // 'commit' changes and send to all clients server.applyChanges(); // start the ROS main loop ros::spin();&#125; Basic Control 告诉你怎样制作一个6-DOF的控件（包括在控制时控件和场景一起移动的，和控件固定的） 关键代码 12 按钮 基本思路 就像菜单栏中的按钮一样 默认是响应鼠标左键 关键代码 12https://raw.githubusercontent.com/ros-visualization/visualization_tutorials/groovy-devel/interactive_marker_tutorials/src/basic_controls.cpp Context Menu 基本思路 将静态菜单附着到一个交互式标记（Interactive Marker）上 多客户端单服务器交互 意义 可以同时有多个RViz客户端控制一个或多个交互式控件Marker 这个例子实现了一个简易乒乓球游戏 以后再学吧。 [为RViz写插件] 感觉没有学这个的需求啊。。。 使用QT和librviz进行窗口程序设计 这个相当于是使用QT对RViz进行简单的二次开发，感觉应该要学，既不需要深度了解QT，又可以编出像样的界面，哈哈！","tags":[{"name":"机器人软件设计","slug":"机器人软件设计","permalink":"https://ZhenshengLee.github.io/tags/机器人软件设计/"}]},{"title":"【ROS】Param reconfig讨论","date":"2016-08-16T08:32:01.000Z","path":"2016/08/16/160816Param-reconfig讨论/","text":"[TOC] 前言 因为windows平台的ROS for LV 没有显式支持action，所以不能直接给move_base节点发送move_base/cancel (actionlib_msgs/GoalID)，故在ROS端添加一个Proxy来代理解决 该代理的功能还包括ROSARIA和move_base的reconfigure，所以要从命令行运行重新配置命令 还修正一个ROSARIA发送的pose_msg内容为相对坐标的问题，改为发送相对于zsWorld坐标系的绝对坐标（在rosaria包中完成） 以后还可以承担打开和关闭各个节点的任务！ 参考ROS WIKI dynamic_reconfigure 工作 ROSARIA坐标修正，并制作一个reconfiguration_server（在rosaria包中完成） 接收上级节点发送的取消service_call，转发给move_base取消action_msg 接收来自上级节点的move_base reconfigure_msg，运行命令行进行重新配置 接收来自上级节点的rosaria reconfigure_msg，运行命令行进行重新配置 接收来及上级节点的重新定位的msg，运行命令行重新配置tf，主要是zsWorld与odom的坐标系转换关系 确认ROS for LV与ROS的连接关系 用rosaria_client进行测试 步骤坐标修正 建立一个包 12catkin_create_pkg zsProxy std_msgs roscpp 修改vscode 配置文件c_cpp_properties.json 12345678910111213141516subl ./.vscode/c_cpp_properties.json&#123; &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [&quot;/usr/include&quot;, &quot;/opt/ros/indigo/include&quot;, &quot;$&#123;ROS_PACKAGE_PATH&#125;&quot;, &quot;/opt/ros/kinetic/include&quot;]&#125;, 修改 .gitignore，vscode的数据文件就不要上传了 12.vscode/ 试用完vscode之后，发现还是CLion IDE爽，配合git 使用需要做一下特殊设置，不然可能会出现无法访问远程仓库问题 settings–&gt;Version Control–&gt;Git ,and then, In the SSH executable dropdown, choose Native 修改rosaria包，增加zs_pose_msg 接下来修改reconfiguration server及配置 学习dynamic config 关于参数概念的详细讨论 主要有两种访问参数的方法，一种是参数服务器，生命周期随roscore；另外一种就是动态重新配置参数，可以在程序运行时进行重新配置参数 关于参数具体实现和模式的讨论 In roslaunch files, tags are for setting a single parameter and tags are for setting groups or more complex structures of parameters. The value set by the tag may only be a string, int, bool, or double, which may be set through the xml attribute value, or by reading in from a text file, bin file, or the output of a command line command. The tag enables users to define a batch of related parameters simultaneously. These can be read from a YAML string which can either be put inline in the launchfile or can be loaded from a file (the rosparam dump command generates YAML output). Unlike the tag, the YAML specification allows nested structures of parameters and parameters with list values. While these data can be represented on the ROS parameter server, it is up to the various client libraries to support complex parameter access. A good example of the tag use in practice is the move_base package, where there are many, many parameters to be set, it’s less cumbersome to just use the YAML format. dynamic reconfig具体技术 窗口程序界面下的重新配置，实际上这是标准的重新配置界面 另外就是使用dynparam command-line tool Service Call-Based Re-configuration 实践 使用上面所述第二种方法，使用命令行执行，可以在shell中执行，不过最好在C++中执行 12rosrun dynamic_reconfigure dynparam set /&lt;node_name&gt; &lt;param&gt; &lt;value&gt; 12system(\"rosrun dynamic_reconfigure dynparam set camera_synchronizer_node narrow_stereo_trig_mode 3\"); 关于dynparam更详细的用法","tags":[{"name":"机器人软件设计","slug":"机器人软件设计","permalink":"https://ZhenshengLee.github.io/tags/机器人软件设计/"}]},{"title":"【ROS】actionlib","date":"2016-08-16T08:29:06.000Z","path":"2016/08/16/160816ros-actionlib/","text":"前言 基础技能，很重要 接上一篇日志 准备看完后，找一个时间给ROS for LabVIEW 加上Action功能，当前项目中利用ROS中一个Proxy节点，将服务请求转换为动作请求 参考 Actionlib Detailed_description Tutorials SimpleActionClientAPI sstream double 字符串转换 tf API 提示 只有一个包或节点是消息，服务，动作的提供者时，在构造描述文件中才需要添加相应的描述语句，如果是接受者，那么不需要提供。 请比较rosaria和rosaria_client构造描述文件的区别 步骤记录学习actionlib基础知识定义：用来为预先发布的任务执行提供接口 The actionlib stack provides a standardized interface for interfacing with preemptable tasks. 综述在ROS中，已经有一种机制，让程序可以向一个节点发送任务请求并收到一次回应，这个机制叫做服务（service），但是在其他很多情况下，如果一个任务需要很长时间完成，用户想要周期性地收到服务器的反馈，这样的机制已经实现，叫做动作，action。 The actionlib package provides tools to create servers that execute long-running goals that can be preempted. It also provides a client interface in order to send requests to the server. 客户端-服务器模型（ROS Action Protocol）协议建立在ros message机制上。 action的具体消息定义（Action Specification） Goal Feedback Result .action file 各种消息的具体定义都在这个文件中*.action 构造描述文件123find_package(catkin REQUIRED genmsg actionlib_msgs actionlib)add_action_files(DIRECTORY action FILES DoDishes.action)generate_messages(DEPENDENCIES actionlib_msgs) 12&lt;depend package=\"actionlib\"/&gt;&lt;depend package=\"actionlib_msgs\"/&gt;","tags":[{"name":"机器人软件设计","slug":"机器人软件设计","permalink":"https://ZhenshengLee.github.io/tags/机器人软件设计/"}]},{"title":"【ROS】ROS中其他有价值的模块","date":"2016-08-16T08:23:56.000Z","path":"2016/08/16/160816ROS中有用的模块/","text":"[TOC] 前言 记录有具有价值的ROS模块并附简单介绍 angles 与几何相关的数学运算库，实现如角度和弧度之间的转换 find_object_2dkey_teleopMongoDB ROS内置的数据库 SMACH 复杂行为生成工具 SMACH is a task-level architecture for rapidly creating complex robot behavior. At its core, SMACH is a ROS-independent Python library to build hierarchical state machines. SMACH is a new library that takes advantage of very old concepts in order to quickly create robust robot behavior with maintainable and modular code. openraveros 作为与openRAVE库的接口端，与其无缝集成 openRAVE是开源的运动规划库，robotic automation virtual environment. Boost库 boost.numeric.ublas boost.numeric.MTL boost.math 贝叶斯滤波器bfl 这是由orocos项目制作分发的贝叶斯滤波器 ROS使用boost中的数学库和随机数发生器等模块对这个库进行编译 This ROS package compiles BFL with the Boost library for matrix operations and random number generation.### orocos_toolchain 由于ROS不具备实时性，所以实现了与另一个机器人软件架构orocos的联合开发，相当于用orocos的实时架构，来使用ROS中已经大量存在的可复用模块 stero_image_processing 专门处理RGBD图像的节点，可以进行预处理，以便进行后续的视觉计算 还可以生成点云 viso2_ros 使用Kinect做视觉里程计的一个包 cotomap 使用八叉树数据结构存储地图，提供整套制图方式的一个库 新版本其中已经包含octoviz八叉树数据结构可视化工具 hector_slam 使用hector_mapping的slam方法 ethzasl_icp_mapping An ICP-based slam tool gmapping 一种使用粒子滤波器进行建图的方法 rgbdslam A solution for SLAM for rgbd cameras universal_robot 最新出的ROS工业机器人的实验性机器人 abb abb机器人 sbpl search based motion planner ompl Open motion planner library chomp_motion_planner chomp_motion_planner rosbridge_suit 使用JSON协议与非ROS程序沟通","tags":[{"name":"机器人软件设计","slug":"机器人软件设计","permalink":"https://ZhenshengLee.github.io/tags/机器人软件设计/"}]},{"title":"【ROS】roscommon详解","date":"2016-08-16T08:16:08.000Z","path":"2016/08/16/160816-roscommon详解/","text":"[TOC] 前言 ROS，其实从本质上讲就是一个消息通信中间件，其最基础的功能就是在ros_common这个包中实现的，如消息，服务，控制台，roslaunch等等，在这里重点学习几个平时没有用到，但也非常重要的模块 参考Wiki Page 记录message_filters基本概念 集中处理多个消息来源的模块，或者说是进行消息同步的模块 一个例子是time synchronizer，其将多个输入消息进行“过滤”（例如消息a，b），只输出消息a的timestamp下的b消息，即对消息b中的“无用”消息进行了“过滤” 基本代码12345// 构造FooFilter foo;BarFilter bar(foo);//Bar的输入连接着foo的输出bar.connectInput(foo);//等价bar.registerCallback(myCallback);//myCallback是一个可调用对象 Time Synchronizer The TimeSynchronizer filter synchronizes incoming channels by the timestamps contained in their headers, and outputs them in the form of a single callback that takes the same number of channels. The C++ implementation can synchronize up to 9 channels. 使用一个回调函数同时处理多个消息，可以按照时间戳将不符合要求的消息丢弃，最多支持9通道，因为c++模板参数最多支持9个 12345678910111213141516171819202122232425262728#include &lt;message_filters/subscriber.h&gt;#include &lt;message_filters/time_synchronizer.h&gt;#include &lt;sensor_msgs/Image.h&gt;#include &lt;sensor_msgs/CameraInfo.h&gt;using namespace sensor_msgs;using namespace message_filters;void callback(const ImageConstPtr&amp; image, const CameraInfoConstPtr&amp; cam_info)&#123; // Solve all of perception here...&#125;int main(int argc, char** argv)&#123; ros::init(argc, argv, \"vision_node\"); ros::NodeHandle nh; message_filters::Subscriber&lt;Image&gt; image_sub(nh, \"image\", 1); message_filters::Subscriber&lt;CameraInfo&gt; info_sub(nh, \"camera_info\", 1); TimeSynchronizer&lt;Image, CameraInfo&gt; sync(image_sub, info_sub, 10); sync.registerCallback(boost::bind(&amp;callback, _1, _2)); ros::spin(); return 0;&#125; 时间同步器现在还支持时间相近的时间戳的消息聚合处理，见后面的Policy-Based Synchronizer Time Sequencer The TimeSequencer filter guarantees that messages will be called in temporal order according to their header’s timestamp. The TimeSequencer is constructed with a specific delay which specifies how long to queue up messages before passing them through. A callback for a message is never invoked until the messages’ time stamp is out of date by at least delay. However, for all messages which are out of date by at least the delay, their callback are invoked and guaranteed to be in temporal order. If a message arrives from a time prior to a message which has already had its callback invoked, it is thrown away. 简单讲，使得消息的回调函数调用能够按照固定时间间隔和按先后顺序执行，如果出现顺序混乱，则将此消息丢弃 Cache 可以存储时间上最近的N个消息 Policy-Based Synchronizer 基于某种策略的消息同步 有两种同步：ExactTime和ApproximateTime Chain 可以将Filter连成一个链 输出与下一个输入相连 ros_bag 记录和重新播放消息数据的工具包，生成一个*.bag文件，此文件可以用Matlab进行解析，也可以在ROS系统中进行重新播放。 详细情况见我的另外一篇播客 ros_graph 进行画图的命令行工具包，在终端显示数据等 使用python命令更好，包括：rostopic, rosnode, rosservice, rosparam XmlRpc++ 是XML-RPC机制的C++实现，XmlRpc是远程过程调用的一种方式，不过更加简单一些，其使用XML作为数据交换格式，使用HTTP协议进行通信。 所有IO都是非阻塞式的，所以网络状态不佳也不会拖慢服务端","tags":[{"name":"机器人软件设计","slug":"机器人软件设计","permalink":"https://ZhenshengLee.github.io/tags/机器人软件设计/"}]},{"title":"【ROS】rosbag-数据记录工具","date":"2016-08-16T05:26:34.000Z","path":"2016/08/16/160816ROS-Bag介绍/","text":"前言 因实验，需要将机器人坐标记录下来，在matlab上做对比实验 需要学习：rosbag的基本使用，bag文件的处理，matlab上ROS工具箱使用 [TOC] 参考 使用示例 rosbag-wiki Bag file format MATLAB working with bag file Bag file rqt_bag rosgab/migration Python 分析rosbag files How to extract data from bag file 记录rosbag基本使用 bag实际上是将一个node的行为录制下来，然后可以重新播放 使用命令行能够：录制，从包重新发布，获取包的概括信息，检查包的消息类型，使用Python表达式过滤包中信息，压缩解压缩包，重新索引包 如果录制高带宽的东西，例如图像信息，建议在本地录制和存放文件 bag文件默认名字为日期，可以添加前缀 基本命令包括 record：制定主题来录制 123456789101112131415161718rosbag record rosout tf cmd_velrosbag record -a #所有rosbag record --duration=30 /chatter #持续30s,5m,2hrosbag record --split --size=1024 /chatter #空间达到1024M后分文件存储rosbag record --split --duration=30 /chatter #持续时间到30s后分文件存储rosbag record -o session1 /chatter #为文件名字做前缀rosbag record -O session2_090210.bag /chatter #为文件命名rosbag record --node=/joy_teleop #录制该节点左右消息rosbag record -l 1000 /chatter # 录制该主题1000个消息限制 info play 注意：如果两个包被播放，它们将作为一个包对待。比如你录制一个包，在一个小时之后再录制一个包，然后同时播放，这个时候你会经历1个小时的空白。 1234567891011121314rosbag play recorede1.bagrosbag play --clock recorded1.bag #发布时钟时间rosbag play --clock --hz=200 recorded1.bag #时钟频率默认100rosbag play -r 10 recorded1.bag # 发布速度翻倍rosbag play -d 5 recorded1.bag #每一次advertise后等待5秒rosbag play -u 240 recorded1.bag #只播放240srosbag play -l recorded1.bag # 循环播放 check 1234rosbag check old.bagrosbag check -g diagnostics.bmr diag.bag #生成一个移植规则文件migration rule file fix 12rosbag fix old.bag repaired.bag myrules.bmr #使用规则文件恢复包文件内容 filter 1234filter &lt;in-bag&gt; &lt;out-bag&gt; &lt;expression&gt; # 详情请访问网页，可以使用topic, m, t, 等要素，分别是主题，消息，时间rosbag filter input.bag output.bag &quot;t.to_sec() &lt;= 1284703931.86&quot; compress decompress reindex 修复包的命令 rqt_bag 提供全方位的图形化界面，具有录制，播放，显示，保存，加载文件，暂停等功能 数据修改 请参考migration网页 数据导出到matlab分析 先导出为CSV文件，逗号分隔值文件格式 1234rostopic echo -b log_file.bag /topic_namerostopic echo -p /topic_name #使用matlab友好格式进行显示 再存为文件 12rostopic echo -b file.bag -p /topic &gt; data.txt","tags":[{"name":"机器人软件设计","slug":"机器人软件设计","permalink":"https://ZhenshengLee.github.io/tags/机器人软件设计/"}]}]